---
title: 面试算法题 汇总
date: 2022-03-17 19:34:10
tags:
  - 算法
  - cpp
categories:
  - 面试算法题
---



面试算法题 汇总

<!--more-->

# 链表与树

## [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)



**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 翻转一个子链表，并且返回新的头与尾
    pair<ListNode *, ListNode *> reverse(ListNode *head, ListNode *tail) {
        ListNode *prev = tail->next;
        ListNode *p = head;
        while (prev != tail) {
            ListNode *nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail, head};
    }

    ListNode *reverseKGroup(ListNode *head, int k) {
        ListNode *hair = new ListNode(0);
        hair->next = head;
        ListNode *pre = hair;

        while (head) {
            ListNode *tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode *nex = tail->next;
            pair<ListNode *, ListNode *> result = reverse(head, tail);
            head = result.first;
            tail = result.second;
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};
```



## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

DFS。

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        path.emplace_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            ret.emplace_back(path);
        }
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};
```



## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        ListNode *hair = new ListNode(-1);
        hair->next = head;

        ListNode *pre = hair;
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *leftNode=pre->next,*rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        ListNode *curr = rightNode->next;

        pre->next = nullptr;
        rightNode->next = nullptr;

        reverse(leftNode);

        pre->next = rightNode;
        leftNode->next = curr;
        return hair->next;
    }

    ListNode* reverse(ListNode *head){
        ListNode *pre=NULL,*p=head,*next;
        while(p){
            next=p->next;
            p->next=pre;
            pre=p;
            p=next;
        }
        return pre;
    }
};
```



## [剑指 Offer II 046. 二叉树的右侧视图](https://leetcode-cn.com/problems/WNC0Lk/)



右视图需要的是每一行最右侧的元素，而如果用DFS来遍历，并且后访问右节点，永远是该行最右侧的节点最后被访问。

所以我们可以直接用数组保存每行最后访问到的节点

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode *root) {
        vector<int> ans;
        preOrder(root, 0, ans);
        return ans;
    }

    void preOrder(TreeNode *root, int depth, vector<int> &ans) {
        if (root == NULL)
            return;
        if (depth == ans.size())
            ans.push_back(0);
        ans[depth] = root->val;
        depth++;
        preOrder(root->left, depth, ans);
        preOrder(root->right, depth, ans);
    }
};
```





## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)



根据二叉搜索树性质，我们知道中序遍历二叉搜索树时，一定会得到升序序列。

这里我们维护一个pre变量，来将遍历到的元素与上一个元素比较，判断是否为升序

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    long long pre = LONG_LONG_MIN;
public:
    bool isValidBST(TreeNode *root) {
        return inOrder(root);
    }

    bool inOrder(TreeNode *root) {
        if (!root)
            return true;
        bool left = inOrder(root->left);
        if (root->val <= pre)
            return false;
        pre = root->val;
        bool right = inOrder(root->right);
        return left && right;
    }
};
```



## [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)



本题运用双指针。

> 怎么让两个速度相同，跑道不同的人相遇？
>
> 答案是交换他们的跑道

我们让两个指针分别从两条链表的头开始向后走，当其中一个链表走到尾端（即指向为空）时，让其从另一个链表头开始再走一遍，直到俩链表相遇或是都为空。

假设A链表长为A，B链表长为B，公共区域长为C。

从A出发的指针pA走完时，长度为A+C，相对的，pB走完时长度为B+C。

这时交换他们的跑道，pA走A+C+B，pB走B+C+A，因他们速度相同，要么在交点相遇，要么都走到空节点，此时返回他们指向的节点即可。

**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *aPtr = headA, *bPtr = headB;
        while (aPtr && bPtr) {
            //如果相同，则找到第一个公共节点
            if (aPtr == bPtr)
                return aPtr;
            aPtr = aPtr->next;
            bPtr = bPtr->next;
            //如果都为空，说明无公共节点
            if (!aPtr && !bPtr)
                return NULL;
            //两个指针走到尽头时，分别切换到另一个链表上
            if (!aPtr)
                aPtr = headB;
            if (!bPtr)
                bPtr = headA;
        }
        return NULL;
    }
};
```



## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)



递归较简单，这里我们用迭代。顺带复习一下DFS。

使用栈储存节点，map或者set储存已访问的节点。

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    stack<TreeNode *> stack;
    vector<int> ans;
    map<TreeNode *, bool> isVisited;
public:
    vector<int> postorderTraversal(TreeNode *root) {
        if (!root)
            return ans;
        stack.push(root);
        while (!stack.empty()) {
            //标记访问到的节点
            isVisited[stack.top()] = true;
            //非空且未访问过，入栈
            if (stack.top()->left && !isVisited.count(stack.top()->left)) {
                stack.push(stack.top()->left);
                continue;
            }
            //同上
            if (stack.top()->right && !isVisited.count(stack.top()->right)) {
                stack.push(stack.top()->right);
                continue;
            }
            //因为是后序，最后输出值并出栈
            ans.push_back(stack.top()->val);
            stack.pop();
        }
        return ans;
    }
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)



层序遍历我们一般使用队列，从左向右遍历时，将下一层的节点加入队列。

此题需要我们进行分层，我们便在while语句中进一步用for来细化各层，将开启每一层时队列的大小当作循环条件。

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    queue<TreeNode *> queue;
    vector<vector<int>> ans;
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        if (!root)
            return ans;
        queue.push(root);
        while (!queue.empty()) {
            //保存该层的大小
            int levelSize = queue.size();
            ans.push_back(vector<int>());
            for (int i = 0; i < levelSize; ++i) {
                TreeNode *node = queue.front();
                ans.back().push_back(node->val);
                if (node->left)
                    queue.push(node->left);
                if (node->right)
                    queue.push(node->right);
                queue.pop();
            }
        }
        return ans;
    }
};
```



## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)



先看如何合并两个链表

- 可以使用额外头节点 head，方便操作。返回结果时返回 `head->next`。
- 使用指针记录新链表遍历到的末尾位置，比较好结果后直接插入尾部。

```c++
ListNode *mergeTwoLists(ListNode *aHead, ListNode *bHead) {                      
    if (!aHead || !bHead)                                                        
        return aHead ? aHead : bHead;                                            
    ListNode *aPtr = aHead, *bPtr = bHead, *head = new ListNode(0), *tail = head;
    while (aPtr && bPtr) {                                                       
        if (aPtr->val < bPtr->val) {                                             
            tail->next = aPtr;                                                   
            aPtr = aPtr->next;                                                   
        } else {                                                                 
            tail->next = bPtr;                                                   
            bPtr = bPtr->next;                                                   
        }                                                                        
        tail = tail->next;                                                       
    }                                                                            
    tail->next = (aPtr ? aPtr : bPtr);                                           
    return head->next;                                                           
}                                                                                
```

对于 K 个链表，我们有两种方案：

1、顺序遍历

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *ans = nullptr;
        for (size_t i = 0; i < lists.size(); ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }
};
```

2、分治

参考归并的思想，将 K 个链表先分，再治。

每一次合并返回合并好的链表。

```c++
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        return merge(lists, 0, lists.size() - 1);
    }

    ListNode *mergeTwoLists(ListNode *aHead, ListNode *bHead) {
        if (!aHead || !bHead)
            return aHead ? aHead : bHead;
        ListNode *aPtr = aHead, *bPtr = bHead, *head = new ListNode(0), *tail = head;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr;
                aPtr = aPtr->next;
            } else {
                tail->next = bPtr;
                bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head->next;
    }

    ListNode *merge(vector<ListNode *> &lists, int l, int r) {
        //分到单个链表时，返回该链表
        if (l == r)
            return lists[l];
        //边界判断
        if (l > r)
            return NULL;
        int mid = (l + r) / 2;
        //返回合并好的链表
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
};
```



## [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)



寻找链表中点 + 链表逆序 + 合并链表

注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

1. 找到原链表的中点。我们可以使用快慢指针来找到链表的中间节点。
2. 将原链表的右半端反转。我们可以使用迭代法实现链表的反转。
3. 将原链表的两端合并。因为两链表长度相差不超过 11，因此直接合并即可。

**注意**

这里的合并并非有序合并，直接一步一步合并即可。

**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode *head) {
        ListNode *aTail = findMid(head), *bHead = aTail->next;
        //拆分链表
        aTail->next = NULL;
        //反转 b 链表
        bHead = reverseList(bHead);
        //合并
        head = mergeTwoList(head, bHead);
    }

    ListNode *findMid(ListNode *head) {
        ListNode *fast = head, *slow = head;
        //快慢指针，fast 走两步，slow 走一步
        while (fast->next) {
            fast = fast->next->next;
            //如果 fast 为空，提前退出，避免在条件中对 fast 进行冗余判断出错
            if (!fast)
                break;
            slow = slow->next;
        }
        return slow;
    }

    ListNode *reverseList(ListNode *head) {
        if (!head)
            return NULL;
        ListNode *pre = NULL, *p = head, *next = head->next;
        //三指针遍历反转
        while (p) {
            next = p->next;
            p->next = pre;
            pre = p;
            p = next;
        }
        return pre;
    }

    ListNode *mergeTwoList(ListNode *aHead, ListNode *bHead) {
        ListNode *head = new ListNode(0), *tail = head;
        ListNode *aPtr = aHead, *bPtr = bHead;
        while (aPtr && bPtr) {
            //合并 a 的一个元素
            tail->next = aPtr;
            aPtr = aPtr->next;
            tail = tail->next;
            //合并 b 的一个元素
            tail->next = bPtr;
            bPtr = bPtr->next;
            tail = tail->next;
        }
        tail->next = aPtr ? aPtr : bPtr;
        return head->next;
    }
};
```



## [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

直接遍历。

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) {
            return head;
        }
        
        ListNode* dummy = new ListNode(0, head);

        ListNode* cur = dummy;
        while (cur->next && cur->next->next) {
            if (cur->next->val == cur->next->next->val) {
                int x = cur->next->val;
                while (cur->next && cur->next->val == x) {
                    cur->next = cur->next->next;
                }
            }
            else {
                cur = cur->next;
            }
        }

        return dummy->next;
    }
};
```



## [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

中序便利的逆序。

直接计数。

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int ans, kNum;
public:
    int kthLargest(TreeNode *root, int k) {
        kNum = k;
        dfs(root);
        return ans;
    }

    void dfs(TreeNode *root) {
        if (!root)
            return;
        dfs(root->right);
        kNum--;
        if (kNum == 0) {
            ans = root->val;
            return;
        }
        dfs(root->left);
    }
};
```



## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

前序得到根节点，到中序中分化左右子树。

在左右子树上继续递归。

```c++
class Solution {
private:
    unordered_map<int, int> index;

public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return nullptr;
        }
        
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = index[preorder[preorder_root]];
        
        // 先把根节点建立出来
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // 构造哈希映射，帮助我们快速定位根节点
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```



# 数据结构

## [381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

哈希表，额外维护数值在列表中**每一次**出现的下标集合。

**代码**

```c++
class RandomizedCollection {
public:
    unordered_map<int, unordered_set<int>> idx;
    vector<int> nums;

    /** Initialize your data structure here. */
    RandomizedCollection() {

    }
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    bool insert(int val) {
        nums.push_back(val);
        idx[val].insert(nums.size() - 1);
        return idx[val].size() == 1;
    }
    
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    bool remove(int val) {
        if (idx.find(val) == idx.end()) {
            return false;
        }
        int i = *(idx[val].begin());
        nums[i] = nums.back();
        idx[val].erase(i);
        idx[nums[i]].erase(nums.size() - 1);
        if (i < nums.size() - 1) {
            idx[nums[i]].insert(i);
        }
        if (idx[val].size() == 0) {
            idx.erase(val);
        }
        nums.pop_back();
        return true;
    }
    
    /** Get a random element from the collection. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
};
```



## [432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)



**代码**

```c++
class AllOne {
    list<pair<unordered_set<string>, int>> lst;
    unordered_map<string, list<pair<unordered_set<string>, int>>::iterator> nodes;

public:
    AllOne() {}

    void inc(string key) {
        if (nodes.count(key)) {
            auto cur = nodes[key], nxt = next(cur);
            if (nxt == lst.end() || nxt->second > cur->second + 1) {
                unordered_set<string> s({key});
                nodes[key] = lst.emplace(nxt, s, cur->second + 1);
            } else {
                nxt->first.emplace(key);
                nodes[key] = nxt;
            }
            cur->first.erase(key);
            if (cur->first.empty()) {
                lst.erase(cur);
            }
        } else { // key 不在链表中
            if (lst.empty() || lst.begin()->second > 1) {
                unordered_set<string> s({key});
                lst.emplace_front(s, 1);
            } else {
                lst.begin()->first.emplace(key);
            }
            nodes[key] = lst.begin();
        }
    }

    void dec(string key) {
        auto cur = nodes[key];
        if (cur->second == 1) { // key 仅出现一次，将其移出 nodes
            nodes.erase(key);
        } else {
            auto pre = prev(cur);
            if (cur == lst.begin() || pre->second < cur->second - 1) {
                unordered_set<string> s({key});
                nodes[key] = lst.emplace(cur, s, cur->second - 1);
            } else {
                pre->first.emplace(key);
                nodes[key] = pre;
            }
        }
        cur->first.erase(key);
        if (cur->first.empty()) {
            lst.erase(cur);
        }
    }

    string getMaxKey() {
        return lst.empty() ? "" : *lst.rbegin()->first.begin();
    }

    string getMinKey() {
        return lst.empty() ? "" : *lst.begin()->first.begin();
    }
};
```



## [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)



LRU是最近最少使用算法，即扔掉最长时间未被使用的元素。我们不仅需要使用map存储键值对，还需要维护一个可更新使用频次的数据结构。

在这里我们使用双向链表，在每次更新某元素频次时，将其移动到链表头位置，所以链表的尾端就是最长时间未被使用的元素。

moveToHead直接实现较为复杂，所以我们可以将它拆分成removeNode和addToHead两部分，且两部分都可复用。

因为我们同时维护两个数据结构，所以不在removeTail中直接释放掉元素，需要拿到它的返回值以同步更新map。

**代码**

```c++
class LRUCache {
    struct Node {
        int key, value;
        Node *prev;
        Node *next;

        Node() : key(0), value(0), prev(NULL), next(NULL) {}

        Node(int key, int value) : key(key), value(value), prev(NULL), next(NULL) {}
    };

    typedef Node *PtrToNode;
    map<int, PtrToNode> map;
    PtrToNode head, tail;
    int size, cap;
public:
    LRUCache(int capacity) {
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
        size = 0;
        cap = capacity;
    }

    int get(int key) {
        if (!map.count(key)) {
            //key不存在
            return -1;
        }
        //如果key存在
        PtrToNode p = map[key];
        moveToHead(p);
        return p->value;
    }

    void put(int key, int value) {
        if (!map.count(key)) {
            //key不存在，向map和链表中添加元素
            PtrToNode node = new Node(key, value);
            map[key] = node;
            addToHead(node);
            size++;
            if (size > cap) {
                //超过容量删除缓存
                PtrToNode removed = removeTail();
                map.erase(removed->key);
                delete removed;
                size--;
            }
        } else {
            //key存在,覆盖value
            PtrToNode node = map[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void removeNode(PtrToNode node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void addToHead(PtrToNode node) {
        head->next->prev = node;
        node->next = head->next;
        head->next = node;
        node->prev = head;
    }

    void moveToHead(PtrToNode node) {
        removeNode(node);
        addToHead(node);
    }

    PtrToNode removeTail() {
        PtrToNode removed = tail->prev;
        removeNode(tail->prev);
        return removed;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



## 构造有序链表



顺序查找和删除即可。

**代码**

```c++
class Solution {
    struct ListNode {
        int val;
        ListNode *next;

        ListNode(int x) {
            val = x;
            next = NULL;
        };
    };

    ListNode *head;

public:
    void creatList() {
        head = new ListNode(0);
    }

    void insert(int num) {
        ListNode *p = head;
        //p最后停在链表满足条件的最后一个节点，但是没有访问到该节点
        while (p->next && p->next->val < num) {
            p = p->next;
        }
        ListNode *node = new ListNode(num);
        node->next = p->next;
        p->next = node;
    }

    void remove(int num) {
        ListNode *p = head->next, *pre = NULL;
        while (p && p->val <= num) {
            if (p->val == num) {
                //移除该节点，但是pre不动
                pre->next = p->next;
                p = p->next;
            } else {
                //正常遍历
                pre = p;
                p = p->next;
            }
        }
    }

    void printList() {
        ListNode *p = head->next;
        while (p) {
            cout << p->val << " ";
            p = p->next;
        }
        cout << endl;
    }
};
```



# 字符串

## [面试题 01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)

快慢双指针。

```c++
class Solution {
public:
    string compressString(string S) {
        int slow = 0, fast = 0;
        string res;
        while (slow < S.size()) {
            while (fast < S.size() && S[slow] == S[fast])
                fast++;
            res += S[slow];
            res += to_string(fast - slow);
            slow = fast;
        }
        return res.length() < S.size() ? res : S;
    }
};
```



## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

滑动窗口。

第一次遍历时，将无关字符标记。

通过维护 needCount 来快速判断当前窗口中是否有足够的字符。

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.size() < t.size()) return "";
        if (s.size() == 1 && t.size() == 1) {
            return s[0] == t[0] ? s : "";
        }
        //哈希表统计字符
        vector<int> need(128);
        //needCount统计所需字符数量
        int needCount = t.size();
        //统计需要的字符
        for (char c: t) {
            need[c]++;
        }
        //不需要的全部变为INT_MIN
        for (int i = 0; i < need.size(); i++) {
            if (need[i] == 0)
                need[i] = INT_MIN;
        }
        //窗口右边界
        int right = 0;
        //目标字符串最小长度
        int len = INT_MAX;
        //目标字符串出发点
        int start = 0;
        for (int left = 0; left < s.size(); left++) {
            //所需字符数量不够时，从窗口一直向右移
            while (right < s.size() && needCount > 0) {
                //对于无关字符直接不去管
                if (need[s[right]] != INT_MIN) {
                    //对于缺的字符，needcount需要减
                    if (need[s[right]] > 0) {
                        needCount--;
                    }
                    //对于不缺的但是是目标字符仍需要减1
                    need[s[right]]--;
                }
                right++;
            }
            //更新目标起点和长度
            if (needCount == 0 && right - left < len) {
                len = right - left;
                start = left;
            }
            //窗口左侧右移1位
            if (need[s[left]] != INT_MIN) {//排除无关字符
                if (need[s[left]] == 0) {//等于0表示右移后会缺少
                    needCount++;
                }
                //小于0的表示还多出来有富余，只需数量减少
                need[s[left]]++;
            }
        }
        return len < INT_MAX ? s.substr(start, len) : "";
    }
};
```



## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

状态机

```c++
class Automaton {
    string state = "start";
    unordered_map<string, vector<string>> table = {
        {"start", {"start", "signed", "in_number", "end"}},
        {"signed", {"end", "end", "in_number", "end"}},
        {"in_number", {"end", "end", "in_number", "end"}},
        {"end", {"end", "end", "end", "end"}}
    };

    int get_col(char c) {
        if (isspace(c)) return 0;
        if (c == '+' or c == '-') return 1;
        if (isdigit(c)) return 2;
        return 3;
    }
public:
    int sign = 1;
    long long ans = 0;

    void get(char c) {
        state = table[state][get_col(c)];
        if (state == "in_number") {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);
        }
        else if (state == "signed")
            sign = c == '+' ? 1 : -1;
    }
};

class Solution {
public:
    int myAtoi(string str) {
        Automaton automaton;
        for (char c : str)
            automaton.get(c);
        return automaton.sign * automaton.ans;
    }
};
```



## 连续字符（不区分大小写）

直接遍历。

```c++
class Solution {
public:
    string maxPower(string s) {
        int len = 1, cnt = 1, idx = 0;
        for (int i = 1; i < s.length(); ++i) {
            if (s[i] == s[i - 1] || s[i] - 32 == s[i - 1] || s[i] + 32 == s[i - 1]) {
                ++cnt;
                if (cnt > len) {
                    len = cnt;
                    idx = i;
                }
            } else {
                cnt = 1;
            }
        }
        return s.substr(idx - len + 1, len);
    }
};
```



## 反转URL



遍历，储存遇到的上一个标识点。

将上一个标识点与当前标识点中间区域反转。

**代码**

```c++
class Solution {
public:
    string reverseURL(string s) {
        string ans = s;
        int pre = 0;
        for (int i = 0; i < ans.length(); ++i) {
            if (ans[i] == '.') {
                reverse(ans.begin() + pre, ans.begin() + i);
                pre = i + 1;
            }
        }
        //最后将顶级域名部分反转
        reverse(ans.begin() + pre, ans.end());
        return ans;
    }
};
```



## [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

直接遍历 + 双指针。

```c++
class Solution {
public:
    string reverseWords(string s) {
        int length = s.length();
        int fast = 0;
        while (fast < length) {
            int slow = fast;
            while (fast < length && s[fast] != ' ') {
                fast++;
            }

            int left = slow, right = fast - 1;
            while (left < right) {
                swap(s[left], s[right]);
                left++;
                right--;
            }
//            reverse(s.begin() + slow, s.begin() + fast);
            while (fast < length && s[fast] == ' ') {
                fast++;
            }
        }
        return s;
    }
};
```



## [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)



这道题我们采用回溯，也叫深度优先搜索。

从第一位开始，首先与包括自己的后面所有字符交换，确定了第一位。

确定第一位之后，向更深一层搜索，即向第二位搜索。将其与包括自己的后面所有字符交换，确定第二位。

以此递归，直到所有位被确定。

**注意**

- 交换时，可用 set 来保存每一层待交换的字符，遇到重复时可剪枝。跳过这个字符继续交换下一个字符。
- 在交换完毕并完成下一层的搜索后，需要恢复交换。以免影响相邻层或是下一次交换。

**代码**

```c++
class Solution {
    vector<string> ans;
public:
    vector<string> permutation(string s) {
        dfs(s, 0);
        return ans;
    }

    void dfs(string s, int depth) {
        //到达最后一层，直接返回
        if (depth == s.size() - 1) {
            ans.push_back(s);
            return;
        }
        //使用set去重
        set<char> set;
        //从x位开始，分别与后面交换
        for (int i = depth; i < s.size(); ++i) {
            //如果待交换的字符重复，剪枝
            if (set.count(s[i]) > 0)
                continue;
            set.insert(s[i]);
            //交换
            swap(s[i], s[depth]);
            //搜索下一层
            dfs(s, depth + 1);
            //恢复交换，避免对s的修改影响相邻层或是下一次交换
            swap(s[i], s[depth]);
        }
    }
};
```



## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

DFS + 回溯

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string str;
        dfs(ans, str, 0, 0, n);
        return ans;
    }

    void dfs(vector<string> &ans, string &cur, int open, int close, int n) {
        //达到深度，结束递归
        if (cur.size() == n * 2) {
            ans.push_back(cur);
            return;
        }
        //左括号数小于 n，可以添加左括号
        if (open < n) {
            cur.push_back('(');
            dfs(ans, cur, open + 1, close, n);
            //回溯
            cur.pop_back();
        }
        //右括号数小于 n，可以添加右括号
        if (close < open) {
            cur.push_back(')');
            dfs(ans, cur, open, close + 1, n);
            cur.pop_back();
        }
    }
};
```



# 单调栈

## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

单调减栈

**代码**

```c++
int trap(vector<int> &height) {
    int ans = 0;
    stack<int> stack;
    for (int i = 0; i < height.size(); i++) {
        while (!stack.empty() && height[stack.top()] < height[i]) {
            int cur = stack.top();
            stack.pop();
            if (stack.empty()) break;
            //计算水量
            int l = stack.top();
            int r = i;
            int h = min(height[r], height[l]) - height[cur];
            ans += (r - l - 1) * h;
        }
        stack.push(i);
    }
    return ans;
}
```



## [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

单调增栈。

**代码**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int> &heights) {
        heights.push_back(0);        //插入空矩形，弹出栈中剩余矩形
        int len = heights.size(), area = 0, pre_index, height, width;
        stack<int> indices;
        for (int i = 0; i < len; i++) {
            while (!indices.empty() && heights[indices.top()] > heights[i]) {    //检查栈是否为空
                pre_index = indices.top();        //储存栈顶矩形的位置
                indices.pop();
                height = heights[pre_index];    //储存高度
                if (indices.empty()) {            //避免操作空栈
                    width = i;                    //若弹出至栈为空，因栈的递增性，边界可向左延伸至0
                } else {
                    width = i - indices.top() - 1;        //储存宽度
                }
                area = area > (width * height) ? area : (width * height);        //更新结果
            }
            indices.push(i);
        }
        return area;
    }
};
```





## [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

每层单调增栈。

**代码**

```c++
class Solution {
public:
    int maximalRectangle(vector<vector<char>> &matrix) {
        int m = matrix.size();
        if (m == 0) {
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> heights(m, vector<int>(n, 0));
        int ans = 0;

        for (int i = 0; i < m; i++) {
            //把每一层转化为柱状图的高度
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    heights[i][j] = (i == 0 ? 0 : heights[i - 1][j]) + 1;
                }
            }
            //保存答案
            ans = max(ans, largestRectangleArea(heights[i]));
        }
        return ans;
    }

    int largestRectangleArea(vector<int> &heights) {
        heights.push_back(0);        //插入空矩形，弹出栈中剩余矩形
        int len = heights.size(), area = 0, pre_index, height, width;
        stack<int> indices;
        for (int i = 0; i < len; i++) {
            while (!indices.empty() && heights[indices.top()] > heights[i]) {    //检查栈是否为空
                pre_index = indices.top();        //储存栈顶矩形的位置
                indices.pop();
                height = heights[pre_index];    //储存高度
                if (indices.empty()) {            //避免操作空栈
                    width = i;                    //若弹出至栈为空，因栈的递增性，边界可向左延伸至0
                } else {
                    width = i - indices.top() - 1;        //储存宽度
                }
                area = area > (width * height) ? area : (width * height);        //更新结果
            }
            indices.push(i);
        }
        return area;
    }
};
```



## 找出第一个比它大的数



单调减栈。

单调栈的核心在于，我们想要什么时候弹出元素。

本题中，我们希望当新元素比栈顶元素大时，弹出栈顶，保存信息。所以我们采用单调减的栈。

在本题中保存索引下标。

**代码**

```c++
class Solution {
public:
    vector<int> firstLargeNumber(vector<int> nums) {
        vector<int> ans(nums.size());
        stack<int> stack;
        stack.push(0);
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > nums[stack.top()]) {
                //比栈顶大时，弹出并处理元素，直到恢复单调
                while (!stack.empty() && nums[i] > nums[stack.top()]) {
                    ans[stack.top()] = nums[i];
                    stack.pop();
                }
                stack.push(i);
            } else {
                stack.push(i);
            }
        }
        //栈中还有剩余元素，说明这些元素右边没有比它大的元素，按顺序弹出处理就好
        while (!stack.empty()) {
            ans[stack.top()] = -1;
            stack.pop();
        }
        return ans;
    }
};
```



## [402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

贪心 + 单调增栈。

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        //使用 vector 模拟栈，避免倒转
        vector<char> stack;
        for (auto &digit: num) {
            while (stack.size() > 0 && stack.back() > digit && k) {
                stack.pop_back();
                k -= 1;
            }
            stack.push_back(digit);
        }

        //移除的数字还不够 k 个时，继续移除
        for (; k > 0; --k) {
            stack.pop_back();
        }

        string ans = "";
        //先假设有前导零
        bool isLeadingZero = true;
        for (auto &digit: stack) {
            //标记前导零
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
    }
};
```

