## 红黑树

是一种不严格的平衡二叉查找树。

### 定义

- 红黑树中的节点，一类被标记为黑色，一类被标记为红色。

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；



### 优点

红黑树是近似平衡的树，在维护平衡的成本上，要比AVL树要低。

所以红黑树的插入、删除、查找等各种操作的性能都比较稳定。



## 哈希

### 构造方法

构造哈希函数的原则是：

（1）函数本身便于计算；

（2）计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。

**1、除留余数法；**

取关键字被某个不大于哈希表长m的数p除后所得的余数为哈希地址。即：

```
H(key)=key MODE p,p<=m.(p的取值最好为素数)。
```

若冲突较多，可取较大的m和p值。
**2、随机法；**
采用一个伪随机函数做哈希函数，即：

```
H(key)=random(key)。其中random为随机函数。
```

通常，当关键字长度不等时采用此法构造哈希函数较为恰当。
**3、平方取中法；**
当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。

这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。

```
例如对于关键key：123。1234^2=1522756，H(k)关键字的哈希地址为：227.
```

**4、折叠法；**

这种方法是按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有折叠法与移位法。移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。

```
例如：key=12360324711202065,哈希表长度为1000，则应把关键字分成3位一段，在此舍去最低的两位65，分别进行移位叠加和折叠叠加，求得哈希地址为105和907。
```

**5、直接定址法；**

取关键字或关键字的某个线性函数值为哈希地址。即：

```
H(key)=key  或 H(key)=a*key+b
```

其中a、b为常数（这种hash函数叫做自身函数）。

**6、数字分析法；**

如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。

```
例如，有1000个记录，关键字为10位十进制整数d1d2d3…d7d8d9d10，如哈希表长取1200，则哈希表的地址空间为：000~1199。
假设经过分析，各关键字中 d3、d5和d7的取值分布较均匀，则哈希函数为：h(key)=h(d1d2d3…d7d8d9d10)=d3d5d7。

例如，h(3748597089)=457，h(9846372561)=432。就是找数字中分布均匀的数字。
```

### 处理冲突

**1、开放定址法，又称下标加1法**

这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：

```
Hi=（H（key）+di）% m  i=1，2，…，n
其中H（key）为哈希函数，m 为表长，di称为增量序列。
```

增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：

（1）线性探测再散列

（2）二次探测再散列

（3）伪随机探测再散列

缺点是：线性探测再散列容易产生“二次聚集”。当删除某个数据的时候，需要设置标记或者移动数据，否则会导致查找的中断。

**2、再哈希法：**

这种方法是同时构造多个不同的哈希函数：

```
Hi=RH1（key）  i=1，2，…，k
```

当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

**3、链地址法；需要额外的空间；**

这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

**4、公共溢出区；**

这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表



## AVL 树

[详细图文——AVL树_带翅膀的猫的博客-CSDN博客_avl树](https://blog.csdn.net/qq_25343557/article/details/89110319)

平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：

它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。

根节点的值大于左子树中的值，小于右子树中的值。



## 堆

堆顶永远是堆中最大或最小的元素。

二叉堆还有一个特性就是每个节点的父节点可以保证比它大，若是取最小值则为比它小。

### 小顶堆实现

```c++
class Heap {
    static const int MAX_N = 1e5 + 10;
    int tree[MAX_N], sz = 0;
public:
    //用作插入数值
    void push(int x) {
        //自己节点的编号
        int i = sz;

        while (i > 0) {
            // 父亲节点的编号
            int p = (i - 1) / 2;
            // 如果已经没有大小颠倒则退出
            if (tree[p] <= x)
                break;
            // 把父亲节点的数值放下来，而把自己提上去
            tree[i] = tree[p];
            i = p;
        }
        tree[i] = x;
        sz++;
    }

    //用作提取并删除最小值
    int pop() {
        // 最小值
        int ret = tree[0];
        sz--;
        // 要提到根的数值
        int x = tree[sz];
        //把提上去的数值清零
        tree[sz] = 0;
        // 从根开始向下交换
        int i = 0;
        while (i * 2 + 1 < sz) {
            //比较儿子的值
            int left = i * 2 + 1, right = i * 2 + 2;
            if (right < sz && tree[right] < tree[left])
                left = right;
            //如果没有大小颠倒则退出
            if (tree[left] >= x)
                break;
            // 把儿子的数值提上来
            tree[i] = tree[left];
            i = left;
        }
        tree[i] = x;
        return ret;
    }

    int top() {
        return tree[0];
    }

    int size(){
        return sz;
    }
};
```