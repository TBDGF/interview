## 事务的特性（ACID）

如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：

**⑴ 原子性（Atomicity）**

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响，就像这个事务从来没有执行过一样。

**⑵ 一致性（Consistency）**

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。一致性是指完整性约束不被破坏，完整性包含实体完整性（主属性不为空）、参照完整性（外键必须存在原表中）、用户自定义的完整性。

**⑶ 隔离性（Isolation）**

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止**多个事务并发执行时由于交叉执行而导致数据的不一致**。**事务隔离**分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

**⑷ 持久性（Durability）**

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



## 隔离级别

1、读取数据时是否占用锁以及所请求的锁类型。

2、占用读取锁的时间。

3、引用其他事务修改的行的读取操作是否。

4、在该行上的写锁被释放之前阻塞其他事务。

5、检索在启动语句或事务时存在的行的已提交版本。

6、读取未提交的数据修改。

**若不考虑隔离性**

 1.**脏读**

脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。

2.**不可重复读**

不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。

3.**幻读**

指一个事务执行两次查询，但第二次查询的结果包含了第一次查询中未出现的数据。

例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

4.**丢失更新**

指两个事务同时更新一行数据，后提交（或撤销）的事务将之前事务提交的数据覆盖了。

丢失更新可分为两类，分别是第一类丢失更新和第二类丢失更新。

- 第一类丢失更新是指两个事务同时操作同一个数据时，当第一个事务撤销时，把已经提交的第二个事务的更新数据覆盖了，第二个事务就造成了数据丢失。
- 第二类丢失更新是指当两个事务同时操作同一个数据时，第一个事务将修改结果成功提交后，对第二个事务已经提交的修改结果进行了覆盖，对第二个事务造成了数据丢失。

**隔离级别**

1.**读未提交（Read uncommitted）**

这种事务隔离级别下，select语句不加锁。

此隔离级别可防止丢失更新。

2.**读已提交（Read committed）**

可避免 脏读 的发生。

3.**可重复读（Repeatable read）**

MySql默认隔离级别。

可避免 脏读 、不可重复读 的发生。

4.**串行化（Serializable ）**

可避免 脏读、不可重复读、幻读 的发生。



## 隔离级别的底层技术

[数据库事务特征、数据库隔离级别，以及各级别数据库加锁情况(含实操)--read uncommitted篇 - 简书 (jianshu.com)](https://www.jianshu.com/p/d75fcdeb07a3)

[MySQL数据库事务各隔离级别加锁情况--read committed && MVCC_慕课手记 (imooc.com)](http://www.imooc.com/article/17290)

[MySQL数据库事务各隔离级别加锁情况--Repeatable Read && MVCC_慕课手记 (imooc.com)](http://www.imooc.com/article/17289)

### MVCC

MVCC的全称是“多版本并发控制”。这项技术使得InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值。这是一个可以用来增强并发性的强大的技术，因为这样的一来的话查询就不用等待另一个事务释放锁。

InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。

> 在Mysql中MVCC是在Innodb存储引擎中得到支持的，Innodb为每行记录都实现了三个隐藏字段：
>
> 6字节的事务ID（DB_TRX_ID）
>
> 7字节的回滚指针（DB_ROLL_PTR）
>
> 隐藏的ID（DB_ROW_ID）
>
> 6字节的事物ID用来标识该行所属的事务，7字节的回滚指针需要了解下Innodb的事务模型。

**增删查改**

在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。

于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：

- SELECT
  - 读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
- INSERT
  - 将当前事务的版本号保存至行的创建版本号
- UPDATE
  - 新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
- DELETE
  - 将当前事务的版本号保存至行的删除版本号

**快照读和当前读**

快照读：读取的是快照版本，也就是历史版本

当前读：读取的是最新版本

普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。



### 锁

- Shared Locks(共享锁/S锁)：

  若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

- Exclusive Locks（排他锁/X锁）：

  若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。

  注意：排他锁会阻止其它事务再对其**锁定的数据**加读或写的锁，但是不加锁的就没办法控制了。

- 更新锁（简记为U锁）：

  用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。

- Record Locks（行锁）：

  行锁，顾名思义，是加在`索引行`(对！是索引行！不是数据行！)上的锁。比如`select * from user where id=1 and id=10 for update`，就会在`id=1`和`id=10`的索引行上加Record Lock。

- Gap Locks（间隙锁）：

  间隙锁，它会锁住两个索引之间的区域。比如`select * from user where id>1 and id<10 for update`，就会在id为(1,10)的索引区间上加Gap Lock。

- Next-Key Locks(间隙锁)：

  也叫间隙锁，它是Record Lock + Gap Lock形成的一个闭区间锁。比如`select * from user where id>=1 and id<=10 for update`，就会在id为[1,10]的索引闭区间上加Next-Key Lock。



**什么时候加锁**

在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:

- select: 即最常用的查询，是不加任何锁的
- select ... lock in share mode: 会加共享锁(Shared Locks)
- select ... for update: 会加排它锁



### 实现原理

**读未提交（READ UNCOMMITTED）**

顾名思义，事务之间可以读取彼此未提交的数据。

`READ UNCOMMITTED`隔离级别下, 读不会加任何锁。而写会加排他锁，并到事务结束之后释放。

实例1：

查-写：查并没有阻止写，表明查肯定并没有加锁，要不写肯定就阻塞了。写很明显，会加排它锁的。

实例2： 

写-写：阻塞，表明，写会加排它锁。

> 在READ UNCOMMITTED级别运行的事务不会发出共享锁，以防止其他事务修改当前事务读取的数据。读取UNCOMMITTED事务也不被排他锁阻止，这将阻止当前事务读取已被修改但未被其他事务提交的行。设置此选项时，可以读取未提交的修改，称为脏读。可以更改数据中的值，并且行可以在事务结束之前在数据集中显示或消失。此选项与在事务中的所有SELECT语句中的所有表上设置NOLOCK具有相同的效果。这是隔离级别的最小限制。

**读已提交（Read committed）**

顾名思义，事务之间可以读取彼此已提交的数据。

InnoDB在该隔离级别(READ COMMITTED)写数据时，使用排它锁, 读取数据不加锁而是使用了MVCC机制。

因此，在读已提交的级别下，都会通过**MVCC**获取当前数据的**最新**快照，不加任何锁，也无视任何锁(因为历史数据是构造出来的，身上不可能有锁)。以此**解决脏读**。

但是，该级别下还是遗留了不可重复读和幻读问题： **MVCC版本的生成时机**: 是每次**select**时。这就意味着，如果我们在事务A中执行多次的select，在每次select之间有其他事务**更新**了我们读取的数据并提交了，那就出现了**不可重复读**，即：重复读时，会出现数据不一致问题，后面我们会讲解超支现象，就是这种引起的。

**可重复读（Repeatable read）**

READ COMMITTED级别不同的是**MVCC版本的生成时机**，即：一次事务在创建trx结构时生成版本，后续的查询都是在这个版本上进行，从而实现了**可重复读**。

1.读不影响写：事务以排他锁的形式修改原始数据，**读时不加锁**，因为 MySQL 在事务隔离级别Read committed 、Repeatable Read下，InnoDB 存储引擎采用非锁定性一致读－－即读取不占用和等待表上的锁。即采用的是MVCC中一致性非锁定读模式。因读时不加锁，所以不会阻塞其他事物在相同记录上加 X锁来更改这行记录。

2.写不影响读：事务以排他锁的形式修改原始数据，当读取的行正在执行 delete 或者 update 操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据。

但是因为MVCC的快照只对**读操作**有效，对**写操作**无效，举例说明会更清晰一点： 事务A依次执行如下3条sql，事务B在语句1和2之间，插入10条age=20的记录，事务A就幻读了。

```sql
1. select count(1) from user where age=20;
-- return 0: 当前没有age=20的
2. update user set name=test where age=20;
-- Affects 10 rows: 因为事务B刚写入10条age=20的记录，而写操作是不受MVCC影响，能看到最新数据的，所以更新成功，而一旦操作成功，这些被操作的数据就会对当前事务可见
3. select count(1) from user where age=20;
-- return 10: 出现幻读
```

**串行化（Serializable）**

大杀器，该级别下，会自动将所有普通`select`转化为`select ... lock in share mode`执行，即针对同一数据的所有读写都变成互斥的了，可靠性大大提高，并发性大大降低。

读-写，写-写均互斥。



## 分布式事务

[从银行转账失败到分布式事务：总结与思考 - xybaby - 博客园 (cnblogs.com)](https://www.cnblogs.com/xybaby/p/7465816.html)

[再论分布式事务：从理论到实践 - xybaby - 博客园 (cnblogs.com)](https://www.cnblogs.com/xybaby/p/7756163.html)



<img src="https://images2017.cnblogs.com/blog/1089769/201710/1089769-20171030194022777-1791638071.png" alt="img" style="zoom:150%;" />



<img src="https://images2017.cnblogs.com/blog/1089769/201710/1089769-20171031182622121-726504272.jpg" alt="img"  />

在上图中，使用了三种分布式事务解决办法：

（1）基于可靠消息的最终一致性方案（异步确保型），这个使用比较广，适用于分支事务大概率成功的情况；

上图中使用于：对应支付系统会计异步记账业务，银行通知结果信息存储与驱动订单处理

（2）TCC事务补偿性方案，使用在同时需要保证一致性与高性能的场景

对应上图中支付系统的订单账户操作：订单处理，资金账户处理，积分账户处理

（3）best effort，最大努力通知型方案，适用于跨平台之间的事务原子性保证

对应上图中支付系统的商户业务通知场景



## 索引结构

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

### B树

B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。下图就是一个典型的B树： 
![这里写图片描述](https://img-blog.csdn.net/20160926140212457)

详细定义：

> 1. 有一个根节点，根节点只有一个记录和两个孩子或者根节点为空；
> 2. 每个节点记录中的key和指针相互间隔，指针指向孩子节点；
> 3. d是表示树的宽度，除叶子节点之外，其它每个节点有[d/2,d-1]条记录，并且些记录中的key都是从左到右按大小排列的，有[d/2+1,d]个孩子；
> 4. 在一个节点中，第n个子树中的所有key，小于这个节点中第n个key，大于第n-1个key，比如上图中B节点的第2个子节点E中的所有key都小于B中的第2个key 9，大于第1个key 3;
> 5. 所有的叶子节点必须在同一层次，也就是它们具有相同的深度；

由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：

```kotlin
BTree_Search(node, key) {
     if(node == null) return null;
     foreach(node.key){
          if(node.key[i] == key) return node.data[i];
          if(node.key[i] > key) return BTree_Search(point[i]->node);
      }
     return BTree_Search(point[i+1]->node);
  }
data = BTree_Search(root, my_key);
```

关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为`logd((N+1)/2)`，检索一个key，其查找节点个数的渐进复杂度为`O(logdN)`。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。

另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以查阅其它文献进行详细研究。



### **B+树**

其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。B-Tree相比，B+Tree有以下不同点：

- 每个节点的指针上限为2d而不是2d+1；
- 内节点不存储data，只存储key；
- 叶子节点不存储指针；

下面是一个简单的B+Tree示意。 

![这里写图片描述](https://img-blog.csdn.net/20160926140413000)

由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。

**带有顺序访问指针的B+Tree**

一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 
![这里写图片描述](https://img-blog.csdn.net/20160926140641162)

如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

### InnoDB B+树

InnoDB的数据文件本身就是索引文件。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 

![这里写图片描述](https://img-blog.csdn.net/20160926141856136)

上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。



InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引： 

![这里写图片描述](https://img-blog.csdn.net/20160926141926745)

这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。



## 索引的结构优化

**联合索引（复合索引）**

首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：

- 第一个字段一定是有序的

- 当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的

  | A | B | C | 
  | 1 | 2 | 3 | 
  | 1 | 4 | 2 | 
  | 1 | 1 | 4 | 
  | 2 | 3 | 5 | 
  | 2 | 4 | 4 | 
  | 2 | 4 | 6 | 
  | 2 | 5 | 5 |

其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。

**最左前缀原理**

我们再来详细介绍一下联合索引的查询。还是上面例子，我们在`（a,b,c）`字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：

以下的查询方式都可以用到索引

```sql
select * from table where a=1；
select * from table where a=1 and b=2；
select * from table where a=1 and b=2 and c=3；
```

上面三个查询按照 `（a ）, （a，b ）,（a，b，c ）`的顺序都可以利用到索引，这就是最左前缀匹配。

如果查询语句是：

```sql
select * from table where a=1 and c=3； 那么只会用到索引a。
```

如果查询语句是：

```sql
select * from table where b=2 and c=3； 因为没有用到最左前缀a，所以这个查询是用户到索引的。
```

如果用到了最左前缀，但是顺序颠倒会用到索引码？

比如：

```sql
select * from table where b=2 and a=1；
select * from table where b=2 and a=1 and c=3；
```

如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。

**前缀索引**

除了联合索引之外，对mysql来说其实还有一种前缀索引。前缀索引就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

一般来说以下情况可以使用前缀索引：

- 字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’
- 字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。
- 前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。

一些文章中也提到：

MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。

**策略**

- 最左前缀匹配原则，上面讲到了
- 主键外键一定要建索引
- 对 where,on,group by,order by 中出现的列使用索引
- 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0
- 对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键
- 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
- 为较长的字符串使用前缀索引
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
- 不要过多创建索引, 权衡索引个数与DML之间关系，DML也就是插入、删除数据操作。这里需要权衡一个问题，建立索引的目的是为了提高查询效率的，但建立的索引过多，会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建
- 对于like查询，”%”不要放在前面。 
  `SELECT * FROM`houdunwang`WHERE`uname`LIKE'后盾%' -- 走索引` 
  `SELECT * FROM`houdunwang`WHERE`uname`LIKE "%后盾%" -- 不走索引`
- 查询where条件数据类型不匹配也无法使用索引 
  字符串与数字比较不使用索引; 
  `CREATE TABLE`a`(`a`char(10));` 
  `EXPLAIN SELECT * FROM`a`WHERE`a`="1"` – 走索引 
  EXPLAIN SELECT * FROM `a` WHERE `a`=1 – 不走索引 
  正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因
