## 跨域请求

[一文搞懂跨域的所有问题，生活从此669~ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/66484450)

- 客户端浏览器解除跨域限制（理论上可以但是不现实）
- 发送JSONP请求替代XHR请求（并不能适用所有的请求方式，不推荐）
- 修改服务器端（包括HTTP服务器和应用服务器）（**推荐**）

**我的实现**

服务器加上

```
"Access-Control-Allow-Origin" : "*"
"Access-Control-Allow-Methods" : "*"
"Access-Control-Allow-Headers" : "*"
```



## 异地登录检测

[防止同一用户在不同地方下登陆的简单实现_Junio_2014的专栏-CSDN博客](https://blog.csdn.net/Junio_2014/article/details/80695644)



## 中间件

**Gin中间件**

[Gin框架入门(四)—中间件_Samdom的博客-CSDN博客_gin 中间件](https://blog.csdn.net/weixin_36162966/article/details/91383006)

**什么是中间件**

说的绝对一点，在业务场景下，与业务无关的都是中间件。包括数据库、离线等。

**中间件的好处**

系统开发更简单 ， 基于成熟的组件来做，可以极大减少技术选择成本。



## Redis 实现乐观锁

乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

在 Redis 中，我们可以通过事务 + Watch 的方式来实现乐观锁。在用户使用 WATCH 命令监视某个键之后，直到该用户执行 EXEC 命令的这段时间里，如果有其他用户抢先对被监视的键进行了替换、更新、删除等操作，那么当用户尝试执行 EXEC 的时候，事务将失败并返回一个错误，用户可以根据这个错误选择重试事务或者放弃事务。

```go
func (c *Client) Watch(fn func(*Tx) error, keys ...string) error
```

watch 的第一个参数是一个返回 error 的 支持事务的函数，watch 会向该函数中传递事务对象。

我们在该函数中对该事务对象调用 TxPipelined，它内部会使用`MULTI/EXEC`包裹排队的命令。

```go
func (c *Tx) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error)
```



## 高并发



### 分布式

> 关键词：More

分布式是一种思想或者架构。支持高并发的同时，带来高可用性。

常见名词：分布式系统、分布式集群、分布式计算、分布式存储、分布式锁、分布式事务。

**分布式的存在，解决问题的同时，也极大地带来了服务端技术的复杂性。**

分布式相关问题：

1. 负载均衡
   1. 常见的负载均衡算法：轮询、随机、加权随机、最小连接数等
   2. 动态的负载均衡算法：一致性哈希
2. 分布式协议算法：Paxos、Raft、ZAB、Gossip
3. CAP理论、BASE理论



### 缓存

> 关键词：Better

缓存的使用，利用了计算机储存介质的金字塔原理。

缓存也可以看作是一种思想，让更快的缓存来提供访问的结果。

缓存的使用在各个维度都有，到处都是。例如：Nginx、浏览器、CDN、MySQL、操作系统等。

常见的缓存，内存（Loacl Cache）、分布式缓存（Redis、Memcached）

**缓存的使用，也会带来相关的复杂性。**比如：

1. 缓存的容量相对不大，需要提高缓存的命中率，让高频的热的数据存在于缓存中。
   1. 缓存的预加载和过期策略；
   2. 缓存的替换算法：LRU、LFU等；
2. 缓存或者多级缓存的使用，当有数据写操作时，会涉及到数据如何同步。
   1. 缓存一致性问题
3. 缓存失效情况的考虑和处理。
   1. 缓存穿透：访问一个缓存和DB都不存在的 key
      1. 接口鉴权：在软件层面就过滤掉一部分一定不存在的 key
      2. 缓存空值
      3. 布隆过滤器（判断不存在的，则一定不存在；判断存在的，大概率存在；比HashMap节省空间）
   2. 缓存击穿：热 key 过期，导致大量请求打到 DB 上
      1. 热 key 不过期，关注更新策略；
   3. 缓存雪崩：大量 key 或者热 key 同时或者密集过期，导致系统压力骤增，引起雪崩
      1. 将过期时间打散
4. 缓存数据结构的选择，关注大 key 等



### 限流

> 关键词：Limit

限流通常是用消息队列来实现的，几种常见的限流算法：**漏桶**、**令牌桶**

**漏桶算法**：通过漏桶算法进行限流，比如每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来的及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。

**令牌桶算法**：在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择等待可用的令牌，或者直接拒绝。

令牌桶算法，除了能限制数据的平均传输速率外，还能允许某种程度的突发流量。



### 降级

在有限的资源下，为了能抗住大量的请求，就需要对系统的分支功能做出一些牺牲，有点“弃卒保帅”的意思。放弃一些功能，保证整个系统能平稳运行。



### 熔断

系统中，由于某些原因使得服务出现了过载现象，为防止整个系统故障，从而采用的一种保护措施，暂时“熔断”对于下游的访问。所以很多地方把熔断亦称为过载保护，熔断一般还可以自动检测修复。



### CAP 理论

CAP 理论指的是一个分布式系统最多只能同时满足一致性（ Consistency ）、可用性（ Availability ）和分区容错性（ Partition tolerance ）这三项中的两项。

- 一致性：读可以读到最近的写（或 error ），所有的 client 独到的内容相同。
- 可用性：所有网络请求都有网络响应，不保证读到的是最新数据，不保证所有 client 读到的内容相同。
- 分区容错性：集群一定能正常工作，即使发生了网络错误或者服务错误；多个 Partition 间出现网络问题，每个 Partition 还可以工作。

事实上，分布式环境下，P 不可减少。



### BASE 理论

基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventually Consisitent）。主要是牺牲了强一致性。



## 布隆过滤器

> 布隆过滤器可以帮助缓解缓存穿透的问题。
>
> 够提高查询效率，也能够节省大量的内存空间。
>
> 但是误判率随着元素的增多会增多，且元素只能插入不能删除

布隆过滤器的底层是比特数组。

数组的每一个元素都只占1bit空间，而且每一个元素只能为0或1。

布隆过滤器拥有 k 个哈希函数，当一个元素加入布隆过滤器时，会使用 k 个哈希函数对其进行 k 次计算,获得 k 个哈希值，而且根据获得的哈希值，在数组中把对应下标的值置位1。

当查询时，如果元素的所有 hash 位置都为 1，说明该值可能存在，因为其中的某一个位可能被其他元素改变过。但是如果不全为 1，至少有 1 个 0 的话，说明元素一定不存在。

**优点**

- 增长和查询元素的时间复杂度为：O(K), (K为哈希函数的个数，通常比较小)，与数据量大小无关
- 哈希函数相互之间没有关系，方便硬件并行运算
- 布隆过滤器不须要存储元素自己，在某些对保密要求比较严格的场合有很大优点
- 在可以承受必定的误判时，布隆过滤器比其余数据结构有这很大的空间优点
- 数据量很大时，布隆过滤器能够表示全集，其余数据结构不能
- 使用同一组散列函数的布隆过滤器能够进行交、并、差运算

**缺点**

- 有误判率，即存在假阳性(False Position)，即不能准确判断元素是否在集合中(补救方法：再创建一个白名单，存储可能会误判的数据)
- 不能获取元素自己
- 通常状况下不能从布隆过滤器中删除元素
- 若是采用计数方式删除，可能会存在计数回绕问题



**如何减少误判**

- 增加二进制位数组的长度。这样经过hash后数据会更加的离散化，出现冲突的概率会大大降低
- 增加Hash的次数，变相的增加数据特征，特征越多，冲突的概率越小



## 分布式事务

[从银行转账失败到分布式事务：总结与思考 - xybaby - 博客园 (cnblogs.com)](https://www.cnblogs.com/xybaby/p/7465816.html)

[再论分布式事务：从理论到实践 - xybaby - 博客园 (cnblogs.com)](https://www.cnblogs.com/xybaby/p/7756163.html)



<img src="https://images2017.cnblogs.com/blog/1089769/201710/1089769-20171030194022777-1791638071.png" alt="img" style="zoom:150%;" />



<img src="https://images2017.cnblogs.com/blog/1089769/201710/1089769-20171031182622121-726504272.jpg" alt="img"  />

在上图中，使用了三种分布式事务解决办法：

（1）基于可靠消息的最终一致性方案（异步确保型），这个使用比较广，适用于分支事务大概率成功的情况；

上图中使用于：对应支付系统会计异步记账业务，银行通知结果信息存储与驱动订单处理

（2）TCC事务补偿性方案，使用在同时需要保证一致性与高性能的场景

对应上图中支付系统的订单账户操作：订单处理，资金账户处理，积分账户处理

（3）best effort，最大努力通知型方案，适用于跨平台之间的事务原子性保证

对应上图中支付系统的商户业务通知场景
