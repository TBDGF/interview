## 链表与树

### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)



先看如何合并两个链表

- 可以使用额外头节点 head，方便操作。返回结果时返回 `head->next`。
- 使用指针记录新链表遍历到的末尾位置，比较好结果后直接插入尾部。

```c++
ListNode *mergeTwoLists(ListNode *aHead, ListNode *bHead) {                      
    if (!aHead || !bHead)                                                        
        return aHead ? aHead : bHead;                                            
    ListNode *aPtr = aHead, *bPtr = bHead, *head = new ListNode(0), *tail = head;
    while (aPtr && bPtr) {                                                       
        if (aPtr->val < bPtr->val) {                                             
            tail->next = aPtr;                                                   
            aPtr = aPtr->next;                                                   
        } else {                                                                 
            tail->next = bPtr;                                                   
            bPtr = bPtr->next;                                                   
        }                                                                        
        tail = tail->next;                                                       
    }                                                                            
    tail->next = (aPtr ? aPtr : bPtr);                                           
    return head->next;                                                           
}                                                                                
```

对于 K 个链表，我们有两种方案：

1、顺序遍历

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode *ans = nullptr;
        for (size_t i = 0; i < lists.size(); ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }
};
```

2、分治

参考归并的思想，将 K 个链表先分，再治。

每一次合并返回合并好的链表。

```c++
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        return merge(lists, 0, lists.size() - 1);
    }

    ListNode *mergeTwoLists(ListNode *aHead, ListNode *bHead) {
        if (!aHead || !bHead)
            return aHead ? aHead : bHead;
        ListNode *aPtr = aHead, *bPtr = bHead, *head = new ListNode(0), *tail = head;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr;
                aPtr = aPtr->next;
            } else {
                tail->next = bPtr;
                bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head->next;
    }

    ListNode *merge(vector<ListNode *> &lists, int l, int r) {
        //分到单个链表时，返回该链表
        if (l == r)
            return lists[l];
        //边界判断
        if (l > r)
            return NULL;
        int mid = (l + r) / 2;
        //返回合并好的链表
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
};
```





### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。



**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 翻转一个子链表，并且返回新的头与尾
    pair<ListNode *, ListNode *> reverse(ListNode *head, ListNode *tail) {
        ListNode *prev = tail->next;
        ListNode *p = head;
        while (prev != tail) {
            ListNode *nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail, head};
    }

    ListNode *reverseKGroup(ListNode *head, int k) {
        ListNode *hair = new ListNode(0);
        hair->next = head;
        ListNode *pre = hair;

        while (head) {
            ListNode *tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode *nex = tail->next;
            pair<ListNode *, ListNode *> result = reverse(head, tail);
            head = result.first;
            tail = result.second;
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};
```



### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

直接遍历。

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) {
            return head;
        }
        
        ListNode* dummy = new ListNode(0, head);

        ListNode* cur = dummy;
        while (cur->next && cur->next->next) {
            if (cur->next->val == cur->next->next->val) {
                int x = cur->next->val;
                while (cur->next && cur->next->val == x) {
                    cur->next = cur->next->next;
                }
            }
            else {
                cur = cur->next;
            }
        }

        return dummy->next;
    }
};
```







### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。




**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        ListNode *hair = new ListNode(-1);
        hair->next = head;

        ListNode *pre = hair;
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *leftNode=pre->next,*rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        ListNode *curr = rightNode->next;

        pre->next = nullptr;
        rightNode->next = nullptr;

        reverse(leftNode);

        pre->next = rightNode;
        leftNode->next = curr;
        return hair->next;
    }

    ListNode* reverse(ListNode *head){
        ListNode *pre=NULL,*p=head,*next;
        while(p){
            next=p->next;
            p->next=pre;
            pre=p;
            p=next;
        }
        return pre;
    }
};

```



### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

**题解**

快慢指针。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast != nullptr) {
            slow = slow->next;
            if (fast->next == nullptr) {
                return nullptr;
            }
            fast = fast->next->next;
            if (fast == slow) {
                ListNode *ptr = head;
                while (ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```







### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)



寻找链表中点 + 链表逆序 + 合并链表

注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

1. 找到原链表的中点。我们可以使用快慢指针来找到链表的中间节点。
2. 将原链表的右半端反转。我们可以使用迭代法实现链表的反转。
3. 将原链表的两端合并。因为两链表长度相差不超过 11，因此直接合并即可。

**注意**

这里的合并并非有序合并，直接一步一步合并即可。

**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode *head) {
        ListNode *aTail = findMid(head), *bHead = aTail->next;
        //拆分链表
        aTail->next = NULL;
        //反转 b 链表
        bHead = reverseList(bHead);
        //合并
        head = mergeTwoList(head, bHead);
    }

    ListNode *findMid(ListNode *head) {
        ListNode *fast = head, *slow = head;
        //快慢指针，fast 走两步，slow 走一步
        while (fast->next) {
            fast = fast->next->next;
            //如果 fast 为空，提前退出，避免在条件中对 fast 进行冗余判断出错
            if (!fast)
                break;
            slow = slow->next;
        }
        return slow;
    }

    ListNode *reverseList(ListNode *head) {
        if (!head)
            return NULL;
        ListNode *pre = NULL, *p = head, *next = head->next;
        //三指针遍历反转
        while (p) {
            next = p->next;
            p->next = pre;
            pre = p;
            p = next;
        }
        return pre;
    }

    ListNode *mergeTwoList(ListNode *aHead, ListNode *bHead) {
        ListNode *head = new ListNode(0), *tail = head;
        ListNode *aPtr = aHead, *bPtr = bHead;
        while (aPtr && bPtr) {
            //合并 a 的一个元素
            tail->next = aPtr;
            aPtr = aPtr->next;
            tail = tail->next;
            //合并 b 的一个元素
            tail->next = bPtr;
            bPtr = bPtr->next;
            tail = tail->next;
        }
        tail->next = aPtr ? aPtr : bPtr;
        return head->next;
    }
};
```



### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**题解**

快慢指针，快指针走到头时慢指针走到中点，同时慢指针反转链表。

然后同时进行遍历比较。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head||!head->next){
            return true;
        }
        ListNode *slow=head,*fast=head;
        ListNode *pre=NULL,*next;
        while(fast&&fast->next){
            fast=fast->next->next;
            next=slow->next;
            slow->next=pre;
            pre=slow;
            slow=next;
        }
        if(fast)
            slow=slow->next;
        while(pre&&slow){
            if(pre->val!=slow->val)
                return false;
            pre=pre->next;
            slow=slow->next;
        }
        return true;
    }
};
```





### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)



本题运用双指针。

> 怎么让两个速度相同，跑道不同的人相遇？
>
> 答案是交换他们的跑道

我们让两个指针分别从两条链表的头开始向后走，当其中一个链表走到尾端（即指向为空）时，让其从另一个链表头开始再走一遍，直到俩链表相遇或是都为空。

假设A链表长为A，B链表长为B，公共区域长为C。

从A出发的指针pA走完时，长度为A+C，相对的，pB走完时长度为B+C。

这时交换他们的跑道，pA走A+C+B，pB走B+C+A，因他们速度相同，要么在交点相遇，要么都走到空节点，此时返回他们指向的节点即可。

**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *aPtr = headA, *bPtr = headB;
        while (aPtr && bPtr) {
            //如果相同，则找到第一个公共节点
            if (aPtr == bPtr)
                return aPtr;
            aPtr = aPtr->next;
            bPtr = bPtr->next;
            //如果都为空，说明无公共节点
            if (!aPtr && !bPtr)
                return NULL;
            //两个指针走到尽头时，分别切换到另一个链表上
            if (!aPtr)
                aPtr = headB;
            if (!bPtr)
                bPtr = headA;
        }
        return NULL;
    }
};
```





### [面试题 02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

**题解**

反向存放：

从两个链表头开始相加，处理进位（单位之和大于10的问题）。创建新的链表节点。然后连接节点

正向存放：

反转链表，然后套用上面解法

```c++
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *hair = new ListNode(-1);
        ListNode *cur = hair;
        int carry = 0, sum = 0;
        while (l1 || l2 || carry) {
            sum = 0;
            if (l1 != NULL) {
                sum += l1->val;
                l1 = l1->next;
            }

            if (l2 != NULL) {
                sum += l2->val;
                l2 = l2->next;
            }

            sum += carry;
            ListNode *temp = new ListNode(sum % 10);
            carry = sum / 10;
            cur->next = temp;
            cur = cur->next;
        }
        return hair->next;
    }
};
```











### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)



根据二叉搜索树性质，我们知道中序遍历二叉搜索树时，一定会得到升序序列。

这里我们维护一个pre变量，来将遍历到的元素与上一个元素比较，判断是否为升序

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    long long pre = LONG_LONG_MIN;
public:
    bool isValidBST(TreeNode *root) {
        return inOrder(root);
    }

    bool inOrder(TreeNode *root) {
        if (!root)
            return true;
        bool left = inOrder(root->left);
        if (root->val <= pre)
            return false;
        pre = root->val;
        bool right = inOrder(root->right);
        return left && right;
    }
};
```



### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)



层序遍历我们一般使用队列，从左向右遍历时，将下一层的节点加入队列。

此题需要我们进行分层，我们便在while语句中进一步用for来细化各层，将开启每一层时队列的大小当作循环条件。

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    queue<TreeNode *> queue;
    vector<vector<int>> ans;
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        if (!root)
            return ans;
        queue.push(root);
        while (!queue.empty()) {
            //保存该层的大小
            int levelSize = queue.size();
            ans.push_back(vector<int>());
            for (int i = 0; i < levelSize; ++i) {
                TreeNode *node = queue.front();
                ans.back().push_back(node->val);
                if (node->left)
                    queue.push(node->left);
                if (node->right)
                    queue.push(node->right);
                queue.pop();
            }
        }
        return ans;
    }
};
```





### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)



递归较简单，这里我们用迭代。顺带复习一下DFS。

使用栈储存节点，map或者set储存已访问的节点。

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    stack<TreeNode *> stack;
    vector<int> ans;
    map<TreeNode *, bool> isVisited;
public:
    vector<int> postorderTraversal(TreeNode *root) {
        if (!root)
            return ans;
        stack.push(root);
        while (!stack.empty()) {
            //标记访问到的节点
            isVisited[stack.top()] = true;
            //非空且未访问过，入栈
            if (stack.top()->left && !isVisited.count(stack.top()->left)) {
                stack.push(stack.top()->left);
                continue;
            }
            //同上
            if (stack.top()->right && !isVisited.count(stack.top()->right)) {
                stack.push(stack.top()->right);
                continue;
            }
            //因为是后序，最后输出值并出栈
            ans.push_back(stack.top()->val);
            stack.pop();
        }
        return ans;
    }
};
```



### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

前序得到根节点，到中序中分化左右子树。

在左右子树上继续递归。

```c++
class Solution {
	//元素：下标
    map<int, int> index;
public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return nullptr;
        }
        
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = index[preorder[preorder_root]];
        
        // 先把根节点建立出来
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // 构造哈希映射，帮助我们快速定位根节点
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```



### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

**代码**



```c++
class Solution {
    int post_root;
    map<int, int> map;
public:
    TreeNode *helper(int in_left, int in_right, vector<int> &inorder, vector<int> &postorder) {
        // 如果这里没有节点构造二叉树了，就结束
        if (in_left > in_right) {
            return nullptr;
        }

        // 选择 post_root 位置的元素作为当前子树根节点
        int root_val = postorder[post_root];
        TreeNode *root = new TreeNode(root_val);

        // 根据 root 所在位置分成左右两棵子树
        int index = map[root_val];

        // 下标减一
        post_root--;
        // 构造右子树
        root->right = helper(index + 1, in_right, inorder, postorder);
        // 构造左子树
        root->left = helper(in_left, index - 1, inorder, postorder);
        return root;
    }

    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
        // 从后序遍历的最后一个元素开始
        post_root = (int) postorder.size() - 1;

        // 建立（元素，下标）键值对的哈希表
        int idx = 0;
        for (auto &val: inorder) {
            map[val] = idx++;
        }
        return helper(0, (int) inorder.size() - 1, inorder, postorder);
    }
};
```



### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

**题解**

DFS。

```c++
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == nullptr) {
            return false;
        }
        if (root->left == nullptr && root->right == nullptr) {
            return sum == root->val;
        }
        return hasPathSum(root->left, sum - root->val) ||
               hasPathSum(root->right, sum - root->val);
    }
};
```



### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

**题解**

DFS

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        path.emplace_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            ret.emplace_back(path);
        }
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};
```





### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

**题解**

DFS。

同时求以该节点为根节点的路径和，和该节点能给父节点最长的路径。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int maxSum = INT_MIN;
public:
    int maxPathSum(TreeNode *root) {
        maxGain(root);
        return maxSum;
    }

    int maxGain(TreeNode *root) {
        if (!root) {
            return 0;
        }
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = max(maxGain(root->left), 0);
        int rightGain = max(maxGain(root->right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = root->val + leftGain + rightGain;

        // 更新答案
        maxSum = max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return root->val + max(leftGain, rightGain);
    }
};
```



### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**题解**

栈。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> ans;
        stack<TreeNode *> stack;
        stack.push(root);
        while (!stack.empty()) {
            TreeNode *top = stack.top();
            stack.pop();
            //先污染，后治理
            if (!top) {
                continue;
            }
            ans.push_back(top->val);
            stack.push(top->right);
            stack.push(top->left);
        }
        return ans;
    }
};
```



### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**题解**

任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int ans;
public:
    int diameterOfBinaryTree(TreeNode *root) {
        ans = 1;
        dfs(root);
        return ans - 1;
    }

    int dfs(TreeNode *rt) {
        if (rt == NULL) {
            return 0; // 访问到空节点了，返回0
        }
        int L = dfs(rt->left); // 左儿子为根的子树的深度
        int R = dfs(rt->right); // 右儿子为根的子树的深度
        ans = max(ans, L + R + 1); // 计算d_node即L+R+1 并更新ans
        return max(L, R) + 1; // 返回该节点为根的子树的深度
    }
};
```



### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

**题解**

层序遍历我们一般使用队列，从左向右遍历时，将下一层的节点加入队列。

此题需要我们进行分层，我们便在while语句中进一步用for来细化各层，将开启每一层时队列的大小当作循环条件。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    queue<TreeNode *> queue;
    vector<vector<int>> ans;
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        if (!root)
            return ans;
        queue.push(root);
        while (!queue.empty()) {
            int levelSize = queue.size();
            ans.push_back(vector<int>());
            for (int i = 0; i < levelSize; ++i) {
                ans.back().push_back(queue.front()->val);
                if (queue.front()->left)
                    queue.push(queue.front()->left);
                if (queue.front()->right)
                    queue.push(queue.front()->right);
                queue.pop();
            }
        }
        return ans;
    }
};
```



### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

**题解**

我们将奇数层和偶数层的操作分开。

level从0开始计数。

- 奇数层：队首读，队尾入。
- 偶数层：队尾读，队首入。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    deque<TreeNode *> deque;
    vector<vector<int>> ans;
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        if (!root)
            return ans;
        deque.push_back(root);
        int level = 0;
        while (!deque.empty()) {
            int levelSize = deque.size();
            ans.push_back(vector<int>());
            for (int i = 0; i < levelSize; ++i) {
                if (level % 2 == 0) {
                    //偶数层，从队尾读，队首入
                    ans.back().push_back(deque.back()->val);
                    if (deque.back()->left)
                        deque.push_front(deque.back()->left);
                    if (deque.back()->right)
                        deque.push_front(deque.back()->right);
                    deque.pop_back();
                } else {
                    //奇数层，队首读，队尾入
                    ans.back().push_back(deque.front()->val);
                    if (deque.front()->right)
                        deque.push_back(deque.front()->right);
                    if (deque.front()->left)
                        deque.push_back(deque.front()->left);
                    deque.pop_front();
                }
            }
            level++;
        }
        return ans;
    }
};
```





### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

中序便利的逆序。

直接计数。

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int ans, kNum;
public:
    int kthLargest(TreeNode *root, int k) {
        kNum = k;
        dfs(root);
        return ans;
    }

    void dfs(TreeNode *root) {
        if (!root)
            return;
        dfs(root->right);
        kNum--;
        if (kNum == 0) {
            ans = root->val;
            return;
        }
        dfs(root->left);
    }
};
```



### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

**题解**

公共祖先一定比左节点大，比右节点小，迭代即可。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
        while (root) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else
                break;
        }
        return root;
    }
};
```



### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

**题解**

DFS

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
        //为空或者找到节点
        if (root == nullptr || root == p || root == q)
            return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        //左右为空，返回空
        //左子树找不到，说明公共祖先在右边
        if (!left)
            return right;
        //右子树找不到，说明公共祖先在左边
        if (!right)
            return left;
        //左右都能找到节点，说明当前是公共祖先
        return root;
    }
};
```





### [剑指 Offer II 046. 二叉树的右侧视图](https://leetcode-cn.com/problems/WNC0Lk/)



右视图需要的是每一行最右侧的元素，而如果用DFS来遍历，并且后访问右节点，永远是该行最右侧的节点最后被访问。

所以我们可以直接用数组保存每行最后访问到的节点

**代码**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode *root) {
        vector<int> ans;
        preOrder(root, 0, ans);
        return ans;
    }

    void preOrder(TreeNode *root, int depth, vector<int> &ans) {
        if (root == NULL)
            return;
        if (depth == ans.size())
            ans.push_back(0);
        ans[depth] = root->val;
        depth++;
        preOrder(root->left, depth, ans);
        preOrder(root->right, depth, ans);
    }
};
```







### 从层序与中序遍历序列构造二叉树



```c++
class Solution {
public:
    TreeNode *buildTree(vector<int> &inorder, vector<int> &levelorder) {
        return build(inorder, levelorder, 0, inorder.size() - 1, 0, inorder.size() - 1);
    }

    TreeNode *
    build(vector<int> &inorder, vector<int> &levelorder, int in_left, int in_right, int level_left, int level_right) {
        if (in_left > in_right)
            return NULL;
        TreeNode *root = new TreeNode();
        int i, j;
        //从层数低的节点开始查找
        for (i = level_left; i <= level_right; i++) {
            //标记未找到
            bool find = false;
            for (j = in_left; j <= in_right; j++) {
                if (levelorder[i] == inorder[j]) {
                    root->val = inorder[j];
                    //找到并标记，退出内层循环
                    find = true;
                    break;
                }
            }
            if (find)
                break;
        }
        if (j >= in_left)
            root->left = build(inorder, levelorder, in_left, j - 1, 0, levelorder.size() - 1);
        if (j <= in_right)
            root->right = build(inorder, levelorder, j + 1, in_right, 0, levelorder.size() - 1);
        return root;
    }
};
```





### 二叉树的最小路径和

给定一棵二叉树，求根节点到叶子节点的最小路径和。

**题解**

DFS。

```c++
class Solution {
public:
    int minSum(TreeNode *root) {
        if (!root)
            return 0;
        //左子树不存在，返回右子树的值 + 根节点值
        if (!root->left)
            return minSum(root->right) + root->val;
        //右子树不存在，返回左子树的值 + 根节点值
        if (!root->right)
            return minSum(root->left) + root->val;
        //左右子树都存在
        return min(minSum(root->left), minSum(root->right)) + root->val;
    }
};
```



## 图论



### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

**题解**

BFS + 拓扑排序

```c++
class Solution {
    // 邻接表存储有向图
    vector<vector<int>> edges;
    // 存储每个节点的入度
    vector<int> indeg;
    int cnt = 0;
public:
    bool canFinish(int numCourses, vector<vector<int>> &prerequisites) {
        edges.resize(numCourses);
        indeg.resize(numCourses);
        for (const auto &info: prerequisites) {
            edges[info[1]].push_back(info[0]);
            ++indeg[info[0]];
        }

        queue<int> q;
        // 将所有入度为 0 的节点放入队列中
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) {
                q.push(i);
            }
        }

        while (!q.empty()) {
            // 从队首取出一个节点
            int u = q.front();
            q.pop();
            cnt++;
            for (int v: edges[u]) {
                --indeg[v];
                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if (indeg[v] == 0) {
                    q.push(v);
                }
            }
        }

        if (cnt != numCourses) {
            return false;
        }
        return true;
    }
};
```



### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

**题解**

BFS + 拓扑排序。

每次选入度为零的点，然后将该点和该点的引用删除，再次选择入度为零的点。

```c++
class Solution {
    // 邻接表存储有向图
    vector<vector<int>> edges;
    // 存储每个节点的入度
    vector<int> indeg;
    // 存储答案
    vector<int> result;

public:
    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites) {
        edges.resize(numCourses);
        indeg.resize(numCourses);
        for (const auto &info: prerequisites) {
            edges[info[1]].push_back(info[0]);
            ++indeg[info[0]];
        }

        queue<int> q;
        // 将所有入度为 0 的节点放入队列中
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) {
                q.push(i);
            }
        }

        while (!q.empty()) {
            // 从队首取出一个节点
            int u = q.front();
            q.pop();
            // 放入答案中
            result.push_back(u);
            for (int v: edges[u]) {
                --indeg[v];
                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if (indeg[v] == 0) {
                    q.push(v);
                }
            }
        }

        if (result.size() != numCourses) {
            return {};
        }
        return result;
    }
};
```



### [1129. 颜色交替的最短路径](https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/)

在一个有向图中，节点分别标记为 0, 1, ..., n-1。图中每条边为红色或者蓝色，且存在自环或平行边。

red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。

返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 answer[x] = -1。

**题解**

```c++
class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<int>> G_red(n), G_blue(n);
        vector<int> D(n, INT_MAX);
        for(auto& e: redEdges) // 构建红色有向图
            G_red[e[0]].emplace_back(e[1]);
        for(auto& e: blueEdges) // 构建蓝色有向图
            G_blue[e[0]].emplace_back(e[1]);
        
        vector<bool> vis_red(n), vis_blue(n);
        queue<pair<int, bool>> q;
        q.emplace(0, true); // 从节点0开始查找红边
        q.emplace(0, false); // 从节点0开始查找蓝边
        int d = 0;
        while(!q.empty()){ // BFS
            int m = q.size();
            while(m--){ // 遍历当前距离的节点
                auto [u, t] = q.front();
                q.pop();
                D[u] = min(D[u], d); // 更新最短距离
                if(t){ // 查找红边
                    for(auto& v: G_red[u]){ // 遍历u节点出发的红边
                        if(!vis_blue[v]){ // 新节点在蓝边中未访问过
                            vis_blue[v] = true; // 标记新节点在蓝边中已访问
                            q.emplace(v, t^1);  // 新节点入队，待查找蓝边
                        }
                    }
                }else{ // 查找蓝边
                    for(auto& v: G_blue[u]){ // 遍历u节点出发的蓝边
                        if(!vis_red[v]){ // 新节点在红边中未访问过
                            vis_red[v] = true; // 标记新节点在红边中已访问
                            q.emplace(v, t^1);  // 新节点入队，待查找红边
                        }
                    }
                }
            }
            d++; // 当前距离+1
        }
        for(auto& d: D)
            if(d == INT_MAX) // 不存在颜色交替最短路径，距离标为-1
                d = -1;
        return D;
    }
};
```



### BFS

```c++
class Solution {
public:
    vector<int> BFS(int nodeNum, vector<vector<int>> &edges, int root) {
        vector<int> ans;
        vector<vector<int>> nodes(nodeNum + 1, vector<int>());
        vector<bool> visited(nodeNum + 1, false);
        for (int i = 0; i < edges.size(); i++) {
            nodes[edges[i][0]].push_back(edges[i][1]);
        }
        queue<int> queue;
        queue.push(root);
        visited[root] = true;
        while (!queue.empty()) {
            int cur = queue.front();
            queue.pop();
            ans.push_back(cur);
            for (int i = 0; i < nodes[cur].size(); i++) {
                if (!visited[nodes[cur][i]]) {
                    queue.push(nodes[cur][i]);
                    visited[nodes[cur][i]] = true;
                }
            }
        }
        return ans;
    }
};
```





## 数据结构



### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)



LRU是最近最少使用算法，即扔掉最长时间未被使用的元素。我们不仅需要使用map存储键值对，还需要维护一个可更新使用频次的数据结构。

在这里我们使用双向链表，在每次更新某元素频次时，将其移动到链表头位置，所以链表的尾端就是最长时间未被使用的元素。

moveToHead直接实现较为复杂，所以我们可以将它拆分成removeNode和addToHead两部分，且两部分都可复用。

因为我们同时维护两个数据结构，所以不在removeTail中直接释放掉元素，需要拿到它的返回值以同步更新map。

**代码**

```c++
class LRUCache {
    struct Node {
        int key, value;
        Node *prev;
        Node *next;

        Node() : key(0), value(0), prev(NULL), next(NULL) {}

        Node(int key, int value) : key(key), value(value), prev(NULL), next(NULL) {}
    };

    typedef Node *PtrToNode;
    map<int, PtrToNode> map;
    PtrToNode head, tail;
    int size, cap;
public:
    LRUCache(int capacity) {
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
        size = 0;
        cap = capacity;
    }

    int get(int key) {
        if (!map.count(key)) {
            //key不存在
            return -1;
        }
        //如果key存在
        PtrToNode p = map[key];
        moveToHead(p);
        return p->value;
    }

    void put(int key, int value) {
        if (!map.count(key)) {
            //key不存在，向map和链表中添加元素
            PtrToNode node = new Node(key, value);
            map[key] = node;
            addToHead(node);
            size++;
            if (size > cap) {
                //超过容量删除缓存
                PtrToNode removed = removeTail();
                map.erase(removed->key);
                delete removed;
                size--;
            }
        } else {
            //key存在,覆盖value
            PtrToNode node = map[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void removeNode(PtrToNode node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void addToHead(PtrToNode node) {
        head->next->prev = node;
        node->next = head->next;
        head->next = node;
        node->prev = head;
    }

    void moveToHead(PtrToNode node) {
        removeNode(node);
        addToHead(node);
    }

    PtrToNode removeTail() {
        PtrToNode removed = tail->prev;
        removeNode(tail->prev);
        return removed;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```





### [381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

为了使得 O(1) 时间内能够随机获取一个元素，我们将每个数值（可以重复）存储在一个列表 nums 中。这样，获取随机元素时，只需要随机生成一个列表中的索引，就能够得到一个随机元素。

这样做的问题在于：列表中的随机删除并不是 O(1) 的。然而我们可以发现，列表中元素的顺序是无关紧要的，只要它们正确地存在于列表中即可。因此，在删除元素时，我们可以将被删的元素与列表中最后一个元素交换位置，随后便可以在 O(1)O(1) 时间内，从列表中去除该元素。

哈希表，额外维护数值在列表中**每一次**出现的下标集合。

**代码**

```c++
class RandomizedCollection {
public:
    unordered_map<int, unordered_set<int>> idx;
    vector<int> nums;

    /** Initialize your data structure here. */
    RandomizedCollection() {

    }
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    bool insert(int val) {
        nums.push_back(val);
        idx[val].insert(nums.size() - 1);
        return idx[val].size() == 1;
    }
    
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    bool remove(int val) {
        if (idx.find(val) == idx.end()) {
            return false;
        }
        int i = *(idx[val].begin());
        nums[i] = nums.back();
        idx[val].erase(i);
        idx[nums[i]].erase(nums.size() - 1);
        if (i < nums.size() - 1) {
            idx[nums[i]].insert(i);
        }
        if (idx[val].size() == 0) {
            idx.erase(val);
        }
        nums.pop_back();
        return true;
    }
    
    /** Get a random element from the collection. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
};
```



### [432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)



**代码**

```c++
class AllOne {
    list<pair<unordered_set<string>, int>> lst;
    unordered_map<string, list<pair<unordered_set<string>, int>>::iterator> nodes;

public:
    AllOne() {}

    void inc(string key) {
        if (nodes.count(key)) {
            auto cur = nodes[key], nxt = next(cur);
            if (nxt == lst.end() || nxt->second > cur->second + 1) {
                unordered_set<string> s({key});
                nodes[key] = lst.emplace(nxt, s, cur->second + 1);
            } else {
                nxt->first.emplace(key);
                nodes[key] = nxt;
            }
            cur->first.erase(key);
            if (cur->first.empty()) {
                lst.erase(cur);
            }
        } else { // key 不在链表中
            if (lst.empty() || lst.begin()->second > 1) {
                unordered_set<string> s({key});
                lst.emplace_front(s, 1);
            } else {
                lst.begin()->first.emplace(key);
            }
            nodes[key] = lst.begin();
        }
    }

    void dec(string key) {
        auto cur = nodes[key];
        if (cur->second == 1) { // key 仅出现一次，将其移出 nodes
            nodes.erase(key);
        } else {
            auto pre = prev(cur);
            if (cur == lst.begin() || pre->second < cur->second - 1) {
                unordered_set<string> s({key});
                nodes[key] = lst.emplace(cur, s, cur->second - 1);
            } else {
                pre->first.emplace(key);
                nodes[key] = pre;
            }
        }
        cur->first.erase(key);
        if (cur->first.empty()) {
            lst.erase(cur);
        }
    }

    string getMaxKey() {
        return lst.empty() ? "" : *lst.rbegin()->first.begin();
    }

    string getMinKey() {
        return lst.empty() ? "" : *lst.begin()->first.begin();
    }
};
```



### 堆

小顶堆

```c++
class Heap {
    static const int MAX_N = 1e5 + 10;
    int tree[MAX_N], sz = 0;
public:
    //用作插入数值
    void push(int x) {
        //自己节点的编号
        int i = sz;

        while (i > 0) {
            // 父亲节点的编号
            int p = (i - 1) / 2;
            // 如果已经没有大小颠倒则退出
            if (tree[p] <= x)
                break;
            // 把父亲节点的数值放下来，而把自己提上去
            tree[i] = tree[p];
            i = p;
        }
        tree[i] = x;
        sz++;
    }

    //用作提取并删除最小值
    int pop() {
        // 最小值
        int ret = tree[0];
        sz--;
        // 要提到根的数值
        int x = tree[sz];
        //把提上去的数值清零
        tree[sz] = 0;
        // 从根开始向下交换
        int i = 0;
        while (i * 2 + 1 < sz) {
            //比较儿子的值
            int left = i * 2 + 1, right = i * 2 + 2;
            if (right < sz && tree[right] < tree[left])
                left = right;
            //如果没有大小颠倒则退出
            if (tree[left] >= x)
                break;
            // 把儿子的数值提上来
            tree[i] = tree[left];
            i = left;
        }
        tree[i] = x;
        return ret;
    }

    int top() {
        return tree[0];
    }

    int size(){
        return sz;
    }
};
```





### 构造有序链表



顺序查找和删除即可。

**代码**

```c++
class Solution {
    struct ListNode {
        int val;
        ListNode *next;

        ListNode(int x) {
            val = x;
            next = NULL;
        };
    };

    ListNode *head;

public:
    void creatList() {
        head = new ListNode(0);
    }

    void insert(int num) {
        ListNode *p = head;
        //p最后停在链表满足条件的最后一个节点，但是没有访问到该节点
        while (p->next && p->next->val < num) {
            p = p->next;
        }
        ListNode *node = new ListNode(num);
        node->next = p->next;
        p->next = node;
    }

    void remove(int num) {
        ListNode *p = head->next, *pre = NULL;
        while (p && p->val <= num) {
            if (p->val == num) {
                //移除该节点，但是pre不动
                pre->next = p->next;
                p = p->next;
            } else {
                //正常遍历
                pre = p;
                p = p->next;
            }
        }
    }

    void printList() {
        ListNode *p = head->next;
        while (p) {
            cout << p->val << " ";
            p = p->next;
        }
        cout << endl;
    }
};
```



## 字符串



### [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

状态机

```c++
class Automaton {
    string state = "start";
    unordered_map<string, vector<string>> table = {
        {"start", {"start", "signed", "in_number", "end"}},
        {"signed", {"end", "end", "in_number", "end"}},
        {"in_number", {"end", "end", "in_number", "end"}},
        {"end", {"end", "end", "end", "end"}}
    };

    int get_col(char c) {
        if (isspace(c)) return 0;
        if (c == '+' or c == '-') return 1;
        if (isdigit(c)) return 2;
        return 3;
    }
public:
    int sign = 1;
    long long ans = 0;

    void get(char c) {
        state = table[state][get_col(c)];
        if (state == "in_number") {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);
        }
        else if (state == "signed")
            sign = c == '+' ? 1 : -1;
    }
};

class Solution {
public:
    int myAtoi(string str) {
        Automaton automaton;
        for (char c : str)
            automaton.get(c);
        return automaton.sign * automaton.ans;
    }
};
```







### [151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

给你一个字符串 s ，颠倒字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**题解**

倒序的快慢指针。

使用快慢指针搜索每一个单词，注意边界。

```c++
class Solution {
public:
    string reverseWords(string s) {
        int fast = s.size() - 1, slow;
        vector<string> vector;
        string ans;
        if (s.empty())
            return ans;
        //初始化到第一个非空字符
        while (fast >= 0 && s[fast] == ' ') {
            fast--;
        }
        slow = fast;
        //每次一个循环遍历一个单词加空隙
        while (fast >= 0) {
            //fast 指针遍历完整单词
            while (fast >= 0 && s[fast] != ' ')
                fast--;
            //将单词添加到数组
            vector.push_back(s.substr(fast + 1, slow - fast));
            //跳过空格
            while (fast >= 0 && s[fast] == ' ')
                fast--;
            slow = fast;
        }
        //拼接字符串
        for (int i = 0; i < vector.size(); ++i) {
            if (i != 0)
                ans += ' ';
            ans += vector[i];
        }
        return ans;
    }
};
```



### [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

给定一个字符串 `s` ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**题解**

直接遍历 + 双指针。

```c++
class Solution {
public:
    string reverseWords(string s) {
        int length = s.length();
        int fast = 0;
        while (fast < length) {
            int slow = fast;
            while (fast < length && s[fast] != ' ') {
                fast++;
            }

            int left = slow, right = fast - 1;
            while (left < right) {
                swap(s[left], s[right]);
                left++;
                right--;
            }
//            reverse(s.begin() + slow, s.begin() + fast);
            while (fast < length && s[fast] == ' ') {
                fast++;
            }
        }
        return s;
    }
};
```



### [面试题 01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)

快慢双指针。

```c++
class Solution {
public:
    string compressString(string S) {
        int slow = 0, fast = 0;
        string res;
        while (slow < S.size()) {
            while (fast < S.size() && S[slow] == S[fast])
                fast++;
            res += S[slow];
            res += to_string(fast - slow);
            slow = fast;
        }
        return res.length() < S.size() ? res : S;
    }
};
```





### 版本数字比较

版本数字比较，比如"1.10.0"版本比"1.8.1"版本新，不允许使用 split 等函数

**题解**

双指针

```c++
class Solution {
public:
    bool versionCompare(string v1, string v2) {
        // 如果 v1 比 v2 新，返回 true，否则返回 false
        int len1 = v1.size();
        int len2 = v2.size();
        int left1 = 0, left2 = 0, right1 = 0, right2 = 0;
        while (right1 < len1 && right2 < len2) {
            left1 = right1;
            left2 = right2;
            while (right1 < len1 && v1[right1] != '.') right1++;
            while (right2 < len2 && v2[right2] != '.') right2++;
            int num1 = stoi(v1.substr(left1, right1 - left1));
            int num2 = stoi(v2.substr(left2, right2 - left2));
            if (num1 > num2)
                return true;
            else if (num1 < num2)
                return false;
            right1++;
            right2++;
        }
        return false;
    }
};
```



### 反转URL



遍历，储存遇到的上一个标识点。

将上一个标识点与当前标识点中间区域反转。

**代码**

```c++
class Solution {
public:
    string reverseURL(string s) {
        string ans = s;
        int pre = 0;
        for (int i = 0; i < ans.length(); ++i) {
            if (ans[i] == '.') {
                reverse(ans.begin() + pre, ans.begin() + i);
                pre = i + 1;
            }
        }
        //最后将顶级域名部分反转
        reverse(ans.begin() + pre, ans.end());
        return ans;
    }
};
```





## 单调栈

### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

单调减栈

**代码**

```c++
int trap(vector<int> &height) {
    int ans = 0;
    stack<int> stack;
    for (int i = 0; i < height.size(); i++) {
        while (!stack.empty() && height[stack.top()] < height[i]) {
            int cur = stack.top();
            stack.pop();
            if (stack.empty()) break;
            //计算水量
            int l = stack.top();
            int r = i;
            int h = min(height[r], height[l]) - height[cur];
            ans += (r - l - 1) * h;
        }
        stack.push(i);
    }
    return ans;
}
```



### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

单调增栈。

**代码**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int> &heights) {
        heights.push_back(0);        //插入空矩形，弹出栈中剩余矩形
        int len = heights.size(), area = 0, pre_index, height, width;
        stack<int> indices;
        for (int i = 0; i < len; i++) {
            while (!indices.empty() && heights[indices.top()] > heights[i]) {    //检查栈是否为空
                pre_index = indices.top();        //储存栈顶矩形的位置
                indices.pop();
                height = heights[pre_index];    //储存高度
                if (indices.empty()) {            //避免操作空栈
                    width = i;                    //若弹出至栈为空，因栈的递增性，边界可向左延伸至0
                } else {
                    width = i - indices.top() - 1;        //储存宽度
                }
                area = area > (width * height) ? area : (width * height);        //更新结果
            }
            indices.push(i);
        }
        return area;
    }
};
```





### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

每层单调增栈。

**代码**

```c++
class Solution {
public:
    int maximalRectangle(vector<vector<char>> &matrix) {
        int m = matrix.size();
        if (m == 0) {
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> heights(m, vector<int>(n, 0));
        int ans = 0;

        for (int i = 0; i < m; i++) {
            //把每一层转化为柱状图的高度
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    heights[i][j] = (i == 0 ? 0 : heights[i - 1][j]) + 1;
                }
            }
            //保存答案
            ans = max(ans, largestRectangleArea(heights[i]));
        }
        return ans;
    }

    int largestRectangleArea(vector<int> &heights) {
        heights.push_back(0);        //插入空矩形，弹出栈中剩余矩形
        int len = heights.size(), area = 0, pre_index, height, width;
        stack<int> indices;
        for (int i = 0; i < len; i++) {
            while (!indices.empty() && heights[indices.top()] > heights[i]) {    //检查栈是否为空
                pre_index = indices.top();        //储存栈顶矩形的位置
                indices.pop();
                height = heights[pre_index];    //储存高度
                if (indices.empty()) {            //避免操作空栈
                    width = i;                    //若弹出至栈为空，因栈的递增性，边界可向左延伸至0
                } else {
                    width = i - indices.top() - 1;        //储存宽度
                }
                area = area > (width * height) ? area : (width * height);        //更新结果
            }
            indices.push(i);
        }
        return area;
    }
};
```





### [402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

贪心 + 单调增栈。

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        //使用 vector 模拟栈，避免倒转
        vector<char> stack;
        for (auto &digit: num) {
            while (stack.size() > 0 && stack.back() > digit && k) {
                stack.pop_back();
                k -= 1;
            }
            stack.push_back(digit);
        }

        //移除的数字还不够 k 个时，继续移除
        for (; k > 0; --k) {
            stack.pop_back();
        }

        string ans = "";
        //先假设有前导零
        bool isLeadingZero = true;
        for (auto &digit: stack) {
            //标记前导零
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
    }
};
```



### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

**题解**



**解法一 保存最小元素信息**

由于栈的特性，每个元素退出、插入后、访问时，该栈的结构不会发生变化，所以我们可以在插入元素时存：**到该元素为止最小的元素**。

这样，每次访问一个元素时，当前栈中最小的元素值一定是该位置保存的最小元素值。

**代码**

```c++
class MinStack {
    struct MinNode {
        int min;
        int value;

        MinNode(int min, int value) : min(min), value(value) {}
    };

    typedef MinNode *PtrToNode;
    stack<PtrToNode> stack;

public:
    /** initialize your data structure here. */
    MinStack() {
        while (!stack.empty()) {
            stack.pop();
        }
    }

    void push(int x) {
        if (stack.empty()) {
            stack.push(new MinNode(x, x));
        } else {
            if (x < stack.top()->min) {
                stack.push(new MinNode(x, x));
            } else {
                stack.push(new MinNode(stack.top()->min, x));
            }
        }
    }

    void pop() {
        stack.pop();
    }

    int top() {
        return stack.top()->value;
    }

    int min() {
        return stack.top()->min;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```



**解法二 单调栈**

使用单调栈，我们维护栈中元素递减。

为了不丢失信息，我们在新元素不符合递减时不弹出栈中元素，而是在符合递减时才加入新元素。

**代码**

```c++
class MinStack {
    //递减栈
    stack<int> minStack;
    stack<int> stack;
public:
    /** initialize your data structure here. */
    MinStack() {
        while (!stack.empty())
            stack.pop();
        while (!minStack.empty()) {
            minStack.empty();
        }
    }

    void push(int x) {
        stack.push(x);
        if (minStack.empty() || x <= minStack.top())
            minStack.push(x);
    }

    void pop() {
        if (stack.empty())
            return;
        if (stack.top() == minStack.top())
            minStack.pop();
        stack.pop();
    }

    int top() {
        if (stack.empty())
            return 0;
        return stack.top();
    }

    int min() {
        if (stack.empty())
            return 0;
        return minStack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```



### 找出第一个比它大的数



单调减栈。

单调栈的核心在于，我们想要什么时候弹出元素。

本题中，我们希望当新元素比栈顶元素大时，弹出栈顶，保存信息。所以我们采用单调减的栈。

在本题中保存索引下标。

**代码**

```c++
class Solution {
public:
    vector<int> firstLargeNumber(vector<int> nums) {
        vector<int> ans(nums.size());
        stack<int> stack;
        stack.push(0);
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > nums[stack.top()]) {
                //比栈顶大时，弹出并处理元素，直到恢复单调
                while (!stack.empty() && nums[i] > nums[stack.top()]) {
                    ans[stack.top()] = nums[i];
                    stack.pop();
                }
                stack.push(i);
            } else {
                stack.push(i);
            }
        }
        //栈中还有剩余元素，说明这些元素右边没有比它大的元素，按顺序弹出处理就好
        while (!stack.empty()) {
            ans[stack.top()] = -1;
            stack.pop();
        }
        return ans;
    }
};
```





## DFS

### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

DFS + 回溯

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string str;
        dfs(ans, str, 0, 0, n);
        return ans;
    }

    void dfs(vector<string> &ans, string &cur, int open, int close, int n) {
        //达到深度，结束递归
        if (cur.size() == n * 2) {
            ans.push_back(cur);
            return;
        }
        //左括号数小于 n，可以添加左括号
        if (open < n) {
            cur.push_back('(');
            dfs(ans, cur, open + 1, close, n);
            //回溯
            cur.pop_back();
        }
        //右括号数小于 n，可以添加右括号
        if (close < open) {
            cur.push_back(')');
            dfs(ans, cur, open, close + 1, n);
            cur.pop_back();
        }
    }
};
```



### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**题解**

DFS + 回溯

```c++
class Solution {
    vector<vector<int>> ans;
public:
    vector<vector<int>> permute(vector<int> &nums) {
        dfs(nums, 0);
        return ans;
    }

    void dfs(vector<int> &nums, int depth) {
        if (depth == nums.size()) {
            ans.push_back(nums);
            return;
        }

        set<int> set;
        for (int i = depth; i < nums.size(); i++) {
            if (set.count(nums[i]) > 0) {
                continue;
            }
            set.insert(nums[i]);
            swap(nums[depth], nums[i]);
            dfs(nums, depth + 1);
            swap(nums[depth], nums[i]);
        }
    }
};
```



### [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**题解**

DFS + 回溯

```c++
class Solution {
    //保存当前结果
    vector<int> cur;
    vector<vector<int>> ans;
public:
    void dfs(int depth, vector<int> &nums) {
        if (depth == nums.size()) {
            ans.push_back(cur);
            return;
        }
        cur.push_back(nums[depth]);
        dfs(depth + 1, nums);
        cur.pop_back();
        dfs(depth + 1, nums);
    }

    vector<vector<int>> subsets(vector<int> &nums) {
        dfs(0, nums);
        return ans;
    }
};
```



### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

**题解**

```c++
class Solution {
public:
    vector<int> cur;
    vector<vector<int>> ans;

    void dfs(bool choosePre, int depth, vector<int> &nums) {
        if (depth == nums.size()) {
            ans.push_back(cur);
            return;
        }
        dfs(false, depth + 1, nums);
        if (!choosePre && depth > 0 && nums[depth - 1] == nums[depth]) {
            return;
        }
        cur.push_back(nums[depth]);
        dfs(true, depth + 1, nums);
        cur.pop_back();
    }

    vector<vector<int>> subsetsWithDup(vector<int> &nums) {
        sort(nums.begin(), nums.end());
        dfs(false, 0, nums);
        return ans;
    }
};
```



### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

DFS。

先污染，后治理。

**代码**

```c++
class Solution {
public:
    int numIslands(vector<vector<char>> &grid) {
        int ans = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    ans++;
                }
            }
        }
        return ans;
    }

    void dfs(vector<vector<char>> &grid, int i, int j) {
        //先污染，后治理
        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == '0')
            return;
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```



### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**题解**

DFS + 回溯。

搜索过的标记为 #。

```c++
class Solution {
    int rows, cols;
    string str;
public:
    bool exist(vector<vector<char>> &board, string word) {
        rows = board.size();
        cols = board[0].size();
        str = word;
        //每一位都要当作起点搜一遍
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (dfs(board, i, j, 0))
                    return true;
            }
        }
        return false;
    }

    bool dfs(vector<vector<char>> &board, int row, int col, int depth) {
        //越界或已经搜索或当前字符不匹配
        if (row >= rows || row < 0 || col >= cols || col < 0 || board[row][col] != str[depth])
            return false;
        //搜索到最后一层，返回
        if (depth == str.size() - 1)
            return true;
        board[row][col] = '#';
        bool res = dfs(board, row + 1, col, depth + 1) || dfs(board, row - 1, col, depth + 1) ||
                   dfs(board, row, col + 1, depth + 1) || dfs(board, row, col - 1, depth + 1);
        //回溯，避免影响别的层的搜索
        board[row][col] = str[depth];
        return res;
    }
};
```



### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)



地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

 **题解**

DFS + 回溯。

本题 DFS 返回值为当前可到达的格子数。

**代码**

```c++
class Solution {
    int rows, cols, kk;
    vector<vector<bool>> isVisited;
public:
    int movingCount(int m, int n, int k) {
        isVisited = vector<vector<bool>>(m, vector<bool>(n));
        rows = m;
        cols = n;
        kk = k;
        return dfs(0, 0);
    }

    int dfs(int row, int col) {
        //越界或是否已访问或不满足条件
        if (row > rows - 1 || col > cols - 1 || isVisited[row][col] || kk < bitSum(row) + bitSum(col))
            return 0;
        isVisited[row][col] = true;
        return 1 + dfs(row + 1, col) + dfs(row, col + 1);
    }

    //求数位和
    int bitSum(int n) {
        int sum = 0;
        while (n != 0) {
            sum += n % 10;
            n /= 10;
        }
        return sum;
    }
};
```



### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

**题解**

DFS + 回溯。

```c++
class Solution {
    vector<string> res;
    string cur;
    char NUM[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

public:
    vector<string> printNumbers(int n) {
        // 数字长度：1 ~ n
        for (int i = 1; i <= n; i++)
            dfs(0, i);
        return res;
    }

    // 生成长度为 len 的数字，正在确定第x位（从左往右）
    void dfs(int depth, int len) {
        if (depth == len) {
            res.push_back(cur);
            return;
        }
        // X=0表示左边第一位数字，不能为0
        int start = depth == 0 ? 1 : 0;
        for (int i = start; i < 10; i++) {
            // 确定本位数字
            cur.push_back(NUM[i]);
            // 确定下一位数字
            dfs(depth + 1, len);
            // 删除本位数字
            cur.pop_back();
        }
    }
};
```



### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

这道题我们采用回溯，也叫深度优先搜索。

从第一位开始，首先与包括自己的后面所有字符交换，确定了第一位。

确定第一位之后，向更深一层搜索，即向第二位搜索。将其与包括自己的后面所有字符交换，确定第二位。

以此递归，直到所有位被确定。

**注意**

- 交换时，可用 set 来保存每一层待交换的字符，遇到重复时可剪枝。跳过这个字符继续交换下一个字符。
- 在交换完毕并完成下一层的搜索后，需要恢复交换。以免影响相邻层或是下一次交换。

**代码**

```c++
class Solution {
    vector<string> ans;
public:
    vector<string> permutation(string s) {
        dfs(s, 0);
        return ans;
    }

    void dfs(string s, int depth) {
        //到达最后一层，直接返回
        if (depth == s.size() - 1) {
            ans.push_back(s);
            return;
        }
        //使用set去重
        set<char> set;
        //从x位开始，分别与后面交换
        for (int i = depth; i < s.size(); ++i) {
            //如果待交换的字符重复，剪枝
            if (set.count(s[i]) > 0)
                continue;
            set.insert(s[i]);
            //交换
            swap(s[i], s[depth]);
            //搜索下一层
            dfs(s, depth + 1);
            //恢复交换，避免对s的修改影响相邻层或是下一次交换
            swap(s[i], s[depth]);
        }
    }
};
```



## 动态规划



### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符
- '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。

**题解**

定义 `dp[i][j]`，从 s 选择前 i 个字符，p 选择 j 个字符，此时选中的字符是否可以匹配。



```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        vector<vector<int>> dp(s.size() + 1, vector<int>(n + 1, false));
        dp[0][0] = true;
        //初始化
        for (int i = 2; i <= n; i++) {
            if (p[i - 1] == '*')
                dp[0][i] = dp[0][i - 2];
        }
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
                } else {
                    dp[i][j] = dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
                }
            }
        }
        return dp[m][n];
    }
};
```



### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**题解**

动态规划。

边界需要初始化。

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>> &grid) {
        if (grid.size() == 0 || grid[0].size() == 0) {
            return 0;
        }
        int rows = grid.size(), cols = grid[0].size();
        auto dp = vector<vector<int> >(rows, vector<int>(cols));
        dp[0][0] = grid[0][0];
        //初始化
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < cols; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        //正式开始动态规划
        for (int row = 1; row < rows; row++) {
            for (int col = 1; col < cols; col++) {
                dp[row][col] = min(dp[row - 1][col], dp[row][col - 1]) + grid[row][col];
            }
        }
        return dp[rows - 1][cols - 1];
    }
};
```





### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- `dp[i][j]` 代表 `word1` 中前 `i` 个字符，变换到 `word2` 中前 `j` 个字符，最短需要操作的次数
- 增，`dp[i][j] = dp[i][j-1] + 1`

- 删，`dp[i][j] = dp[i - 1][j] + 1`
- 改，`dp[i][j] = dp[i - 1][j - 1] + 1`

**代码**

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));

        //初始化额外的位置
        for (int i = 0; i < dp.size(); i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j < dp[0].size(); j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i < dp.size(); i++) {
            for (int j = 1; j < dp[i].size(); j++) {
                dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        return dp.back().back();
    }
};
```



### [688. 骑士在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)

在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png)

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 k 步或离开了棋盘。

返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。

**题解**

加上时间维度的二维动态规划。

`dp[i][j][step] += dp[nx][ny][step - 1] / 8;`

```c++
class Solution {
    //八种方向
    vector<vector<int>>
            dirs = {{-1, -2},
                    {-1, 2},
                    {1,  -2},
                    {1,  2},
                    {-2, 1},
                    {-2, -1},
                    {2,  1},
                    {2,  -1}};
public:
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k + 1)));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j][0] = 1;
            }
        }
        for (int step = 1; step <= k; step++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    for (auto vector: dirs) {
                        int nx = i + vector[0], ny = j + vector[1];
                        if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
                        dp[i][j][step] += dp[nx][ny][step - 1] / 8;
                    }
                }
            }
        }
        return dp[row][column][k];
    }
};
```



### [983. 最低票价](https://leetcode-cn.com/problems/minimum-cost-for-tickets/)

在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。

火车票有 三种不同的销售方式 ：

一张 为期一天 的通行证售价为 costs[0] 美元；
一张 为期七天 的通行证售价为 costs[1] 美元；
一张 为期三十天 的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张 为期 7 天 的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。

返回 你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费 。

**题解**

- 定义

  - d[i]表示i天的最低花费
  - 转换：这里为了计算日期差额方便，直接就按照每一天来定义d的大小，对于[1,4,6,7,8,20],预留一个边缘0的情况，就是20+1=21,

- 
  初始化

  - d[i] = 0


- 计算
  - 从前往后去计算
  - 判断当天是否在 days 里
    - 不存在：那天不需要旅游，费用和前一天一样，d[i] = d[i-1]
    - 存在：考虑3种情况下费用的的最小值，d[i]=min(d[i-k] + cost[ki] ) 其中k的取值是1，7，30， 而ki取值是0,1,2

- 结果
  - d[last] 最后一个就是最后一天的花费

```c++
class Solution {
public:
    int mincostTickets(vector<int> &days, vector<int> &costs) {
        int last = days.back();
        vector<int> dp(last + 1);
        // 当前days的序号，只有相等时候才加1
        int curDay = 0;
        for (int i = 1; i <= last; ++i) {
            if (days[curDay] != i) {
                // 不出行的一天，那么就和上一天一样的花费
                dp[i] = dp[i - 1];
            } else {
                // 考虑三种情况的最小值，记得考虑边缘情况就是 i-k < 0
                dp[i] = min(min(dp[(i - 1) >= 0 ? (i - 1) : 0] + costs[0], dp[(i - 7) >= 0 ? (i - 7) : 0] + costs[1]),
                            dp[(i - 30) >= 0 ? (i - 30) : 0] + costs[2]);
                ++curDay;
            }
        }
        return dp[last];
    }
};
```



### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

**题解**

定义数组 dp，其中 dp[i] 表示第 i 个 丑数，第 n 个丑数即为 dp[n]。

dp[1] = 1。

定义三个指针 p2 p3 p5，表示下一个丑数是当前指针指向的丑数乘以对应的质因数，起初，三个指针的值都是 1。

当 `2 <= i<= n` 时，令 `dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)` 然后将对应的指针加 1。

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n + 1);
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for (int i = 2; i <= n; i++) {
            int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;
            dp[i] = min(min(num2, num3), num5);
            if (dp[i] == num2) {
                p2++;
            }
            if (dp[i] == num3) {
                p3++;
            }
            if (dp[i] == num5) {
                p5++;
            }
        }
        return dp[n];
    }
};
```



### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

**题解**

`dp[i][j]` 表示 i 个骰子，投出 j 的概率。

每一个位置，都有六种情况，可由上一次掷骰的结果算出并分别累加。

```c++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        vector<double> ans(n * 5 + 1);
        vector<vector<double>> dp(n + 1, vector<double>(n * 6 + 1));
        for (int i = 1; i <= 6; i++) {
            dp[1][i] = 1.0 / 6;
        }
        for (int i = 2; i <= n; i++) {
            for (int j = i; j <= i * 6; j++) {

                //遍历点数 1 到 6
                for (int k = 1; k <= 6; k++) {
                    //防止越界
                    if (j - k > 0)
                        dp[i][j] += dp[i - 1][j - k] / 6;
                    else
                        break;
                }
            }
        }
        for (int i = 0; i <= 5 * n; ++i) {
            ans[i] = dp[n][n + i];
        }
        return ans;
    }
};
```



## 子序列与数组

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**题解**

动态规划。

`dp[i][j]` 表示字符串 s 的 第 i 到 j 个字母组成的串是否为回文串。

`dp[i][j] = dp[i + 1][j - 1] & (s[i] == s[j])`

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.size() <= 1) {
            return s;
        }
        int maxLen = 1;
        int begin = 1;
        vector<vector<int>> dp(s.size() + 1, vector<int>(s.size() + 1));
        for (int i = 1; i <= s.size(); i++) {
            dp[i][i] = true;
        }
        for (int len = 1; len <= s.size(); len++) {
            for (int i = 1; i < s.size(); ++i) {
                int j = i + len - 1;
                if (j > s.size())
                    break;
                if (s[i - 1] != s[j - 1]) {
                    dp[i][j] = false;
                } else {
                    if (len <= 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && len > maxLen) {
                    maxLen = len;
                    begin = i;
                }
            }
        }
        return s.substr(begin - 1, maxLen);
    }
};
```



### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。

**题解**

滑动窗口。

第一次遍历时，将无关字符标记。

通过维护 needCount 来快速判断当前窗口中是否有足够的字符。

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.size() < t.size()) return "";
        if (s.size() == 1 && t.size() == 1) {
            return s[0] == t[0] ? s : "";
        }
        //哈希表统计字符
        vector<int> need(128);
        //needCount统计所需字符数量
        int needCount = t.size();
        //统计需要的字符
        for (char c: t) {
            need[c]++;
        }
        //不需要的全部变为INT_MIN
        for (int i = 0; i < need.size(); i++) {
            if (need[i] == 0)
                need[i] = INT_MIN;
        }
        //窗口右边界
        int right = 0;
        //目标字符串最小长度
        int len = INT_MAX;
        //目标字符串出发点
        int start = 0;
        for (int left = 0; left < s.size(); left++) {
            //所需字符数量不够时，从窗口一直向右移
            while (right < s.size() && needCount > 0) {
                //对于无关字符直接不去管
                if (need[s[right]] != INT_MIN) {
                    //对于缺的字符，needcount需要减
                    if (need[s[right]] > 0) {
                        needCount--;
                    }
                    //对于不缺的但是是目标字符仍需要减1
                    need[s[right]]--;
                }
                right++;
            }
            //更新目标起点和长度
            if (needCount == 0 && right - left < len) {
                len = right - left;
                start = left;
            }
            //窗口左侧右移1位
            if (need[s[left]] != INT_MIN) {//排除无关字符
                if (need[s[left]] == 0) {//等于0表示右移后会缺少
                    needCount++;
                }
                //小于0的表示还多出来有富余，只需数量减少
                need[s[left]]++;
            }
        }
        return len < INT_MAX ? s.substr(start, len) : "";
    }
};
```



### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

**题解**

set

先遍历数组，将数字都存入到 HashSet 中便于在常量时间内找到值是否存在。然后再次遍历数组，当 set 中不存在 num-1 的时候，表示这是起点，然后寻找 num + 1， num + 2 ... num + k 是否存在，更新结果即可。

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};
```

map

建立一个哈希表，记录每个元素num能够连续到达的右边界，这样在内层循环遍历到一个新元素时，无需经过多次+1「遍历+判断」才能到达右边界，直接取值即可。

```c++
class Solution {
public:
    int longestConsecutive(vector<int> &nums) {
        map<int, int> map;
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]] = nums[i];
        }
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (!map.count(nums[i]-1)) {
                int right = map[nums[i]];
                while (map.count(right + 1)) {
                    right = map[right + 1];
                }
                map[nums[i]] = right;
                ans = max(ans, right - nums[i] + 1);
            }
        }
        return ans;
    }
};
```



### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

**题解**

滑动窗口。

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int> &nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```





### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

**题解**

我们将两个 s 连在一起，并移除第一个和最后一个字符。如果 s 是该字符串的子串，那么 s 就满足题目要求。

库函数

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();
    }
};
```

KMP

```c++
class Solution {
public:
    bool kmp(const string& query, const string& pattern) {
        int n = query.size();
        int m = pattern.size();
        vector<int> fail(m, -1);
        for (int i = 1; i < m; ++i) {
            int j = fail[i - 1];
            while (j != -1 && pattern[j + 1] != pattern[i]) {
                j = fail[j];
            }
            if (pattern[j + 1] == pattern[i]) {
                fail[i] = j + 1;
            }
        }
        int match = -1;
        for (int i = 1; i < n - 1; ++i) {
            while (match != -1 && pattern[match + 1] != query[i]) {
                match = fail[match];
            }
            if (pattern[match + 1] == query[i]) {
                ++match;
                if (match == m - 1) {
                    return true;
                }
            }
        }
        return false;
    }

    bool repeatedSubstringPattern(string s) {
        return kmp(s + s, s);
    }
};
```



### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回该数组中和为 `k` 的连续子数组的个数。

**题解**

前缀和 + 哈希表优化。

`pre[i] - k = pre[i - 1]`

哈希表储存前缀和与该前缀和出现的次数。

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int count = 0, pre = 0;
        for (auto& x:nums) {
            pre += x;
            if (mp.count(pre - k)>0) {
                count += mp[pre - k];
            }
            mp[pre]++;
        }
        return count;
    }
};
```





### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)



通常，涉及连续子数组问题的时候，我们使用前缀和来解决。

本题部分思路与 [面试算法题 03 - Allen Ji's blog](https://blog.allenji.cn/p/9160/) 中的 ”求出反转的数字对“ 类似。都是保存出现过的次数，每次向结果上累加该次数。

我们令前缀和 `P[i] = nums[0] + nums[1] + ... + nums[i]`，那么每个连续从 i 到 j 的子数组的和 `sum(i, j)` 就可以写成 `P[j] - P[i-1]` 的形式。因此判断能否被 k 整除等价于判断 `(P[j] - P[i-1]) % k == 0` 。

根据**同余定理**，上面的判断式可转化为 `P[j] % k == P[i-1] % k`。

因此，我们只需要保存 `P[i] % k` 的值到 map 中，同时记录出现过的次数，即可记录出有多少子数组。（每出现一对左右边界，相当于出现一次子数组，所以本题与 ”求出反转的数组对“ 思路非常相近）

注意边界，考虑第一个子数组就能被 k 整除的情况，这时没有记录过左边界，所以我们在 map 中初始化进左边界。

**代码**

```c++
class Solution {
public:
    int subarraysDivByK(vector<int> &nums, int k) {
        //初始化，考虑前缀和被 k 整除的情况，即第一个子数组就能被 k 整除
        map<int, int> record = {{0, 1}};
        //sum 记录前缀和，ans记录结果
        int sum = 0, ans = 0;
        for (int i = 0; i < nums.size(); ++i) {
            sum += nums[i];
            //c++ 对负数取模结果为负数，通过先加 k 再模 k 来纠正
            int modulus = (sum % k + k) % k;
            if (record.count(modulus) != 0)
                //当多次出现同模的结果时，加上之前保存过的对数
                ans += record[modulus];
            //对数增加
            record[modulus]++;
        }
        return ans;
    }
};
```





### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

**题解**

二维dp，`dp[i][j]` 保存 A 字符串的第 i 位和 B 字符串的第 j 位之前的最大公共子序列。

- 如果 ` text1[i] == text2[j]`，说明可以继承 `dp[i-1][j-1]` 位置上的子序列，`dp[i][j] = dp[i - 1][j - 1] + 1`
- 如果 ` text1[i] != text2[j]`，考虑向两个方向寻找，`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`

![image.png](https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/9160/1617411822-KhEKGw-image.png)

**代码**

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        //为省略边界判断，将矩阵扩大一圈，边界就自动初始化为 0 了
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        //因为扩大了矩阵，i 和 j 都从 1 开始遍历
        for (int i = 1; i <= m; ++i) {
            char ch1 = text1[i - 1];
            for (int j = 1; j <= n; ++j) {
                char ch2 = text2[j - 1];
                if (ch1 == ch2)
                    //继承
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    //向两个方向寻找最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m][n];
    }
};
```





### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)



请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

**题解**

动态规划。

使用 dp 数组存到当前位置为止，最长不重复子串。用 map 存每个字符在当前子串里的位置。

当遇到重复字符，我们用当前位置减去字符在上一个子串里的位置得到裁剪出的新串长度。

但如果裁剪出的新串长度大于累加得到的新串长度，说明该字符已经在过去被裁剪过，现在只要累加就好。

**代码**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.empty())
            return 0;
        map<char, int> map;
        vector<int> dp(s.size());
        dp[0] = 1;
        map[s[0]] = 0;
        int ans = 1;
        for (int i = 1; i < s.size(); ++i) {
            if (map.count(s[i]) > 0 && i - map[s[i]] < dp[i - 1]+1) {
                //裁剪出的新串长度小于累加得到的新串长度，说明该字符在过去被裁剪过
                dp[i] = i - map[s[i]];
            } else
                dp[i] = dp[i - 1] + 1;
            ans = max(dp[i], ans);
            map[s[i]] = i;
        }
        return ans;
    }
};
```













### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

**题解**

滑动窗口，当 sum < target 时，sum +=j，j++；当 sum > target 时，sum -=i，i++；否则将 i 到 j 的数字添加到数组中。

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> ans;
        vector<int> cur;
        for (int left = 1, right = 2; left < right;) {
            int sum = (left + right) * (right - left + 1) / 2;
            if (sum == target) {
                cur.clear();
                for (int i = left; i <= right; ++i) {
                    cur.emplace_back(i);
                }
                ans.emplace_back(cur);
                left++;
            } else if (sum < target) {
                right++;
            } else {
                left++;
            }
        }
        return ans;
    }
};
```





### 连续字符（不区分大小写）

直接遍历。

```c++
class Solution {
public:
    string maxPower(string s) {
        int len = 1, cnt = 1, idx = 0;
        for (int i = 1; i < s.length(); ++i) {
            if (s[i] == s[i - 1] || s[i] - 32 == s[i - 1] || s[i] + 32 == s[i - 1]) {
                ++cnt;
                if (cnt > len) {
                    len = cnt;
                    idx = i;
                }
            } else {
                cnt = 1;
            }
        }
        return s.substr(idx - len + 1, len);
    }
};
```



### 最接近 target 的连续子数组

滑动窗口。

```
	public int[] findNearest(int[] s, int target) {
		int head = 0, tail = 0;
		int rH = 0, rT = 0;
		int res = s[0];
		int temp = 0;
		while(head<s.length && tail<s.length) {
			if(temp < target) {
				temp += s[tail];
				tail ++;
			}else if(temp > target){
				temp -= s[head];
				head++;
			}else {
				break;
			}
			if(Math.abs(res-target) >= Math.abs(temp - target)) {
				res = temp;
				rH = head;
				rT = tail;
			}
		}
		int[] ans = new int[rT - rH];
		for(int i=0;i<ans.length;i++) {
			ans[i] = s[rH+i];
		}
		return ans;
	}
```







## 其他

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**题解**

保存 `target - nums[i]`。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int> map;
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            if(map.count(nums[i])>0){
                ans.push_back(i);
                ans.push_back(map[nums[i]]);
            }
            map[target-nums[i]]=i;
        }
        return ans;
    }
};
```



### [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

**题解**

两边二分，比较谁更小。

更小的说明他前面的数都比中位数小，所以越过他们继续寻找。

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {
        int n = nums1.size() + nums2.size();
        if (n % 2 == 1)
            return getKth(nums1, nums2, (n + 1) / 2);
        else
            return (getKth(nums1, nums2, n / 2) + getKth(nums1, nums2, n / 2 + 1)) / 2.0;
    }

    int getKth(vector<int> &nums1, vector<int> &nums2, int k) {
        int start1 = 0, start2 = 0;
        int len1 = nums1.size(), len2 = nums2.size();
        while (true) {
            //其中一个数组已经遍历完，返回另一个数组中的第 k 个
            if (start1 == len1)
                return nums2[start2 + k - 1];
            if (start2 == len2)
                return nums1[start1 + k - 1];
            //k 等于一，找两个数组中最小的第一个的就行
            if (k == 1)
                return min(nums1[start1], nums2[start2]);

            //将 k 二分，同时避免越界
            int newStart1 = min(start1 + k / 2 - 1, len1 - 1);
            int newStart2 = min(start2 + k / 2 - 1, len2 - 1);


            if (nums1[newStart1] <= nums2[newStart2]) {
                //如果数组 1 中二分的 k 小，说明中位数不在数组 1 中，将 start1 提高
                k -= newStart1 - start1 + 1;
                start1 = newStart1 + 1;
            } else {
                //同理
                k -= newStart2 - start2 + 1;
                start2 = newStart2 + 1;
            }
        }
    }
};
```





### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**题解**

排序+双指针。

两个指针划定边界，中间指针遍历区间。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int> &nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
    }
};
```



### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

**题解**

二分，先判断 mid 落在左半数组还是右半数组。

再分类讨论。

```c++
class Solution {
public:
    int search(vector<int> &nums, int target) {
        int n = (int) nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            //找到，直接返回
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                //mid 在左半数组
                if (nums[0] <= target && target < nums[mid]) {
                    //mid 在 target 右边，向左收缩边界
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                //mid 在右半数组
                if (nums[mid] < target && target <= nums[n - 1]) {
                    //mid 在 target 左边，向右搜索边界
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



### [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

交换。每一个错误的位置就代表了一个缺失的正数。

**代码**

```c++
class Solution {
public:
    int firstMissingPositive(vector<int> &nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[nums[i] - 1], nums[i]);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
};
```





### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**题解**

按顺序模拟。

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>> &matrix) {
        vector<int> ans;
        int top = 0, bottom = matrix.size() - 1, left = 0, right = matrix[0].size() - 1;
        while (true) {
            for (int i = left; i <= right; i++) {
                ans.push_back(matrix[top][i]);
            }

            if (top++ >= bottom) break;
            for (int i = top; i <= bottom; i++) {
                ans.push_back(matrix[i][right]);
            }

            if (right-- <= left) break;
            for (int i = right; i >= left; i--)
                ans.push_back(matrix[bottom][i]);

            if (bottom-- <= top) break;
            for (int i = bottom; i >= top; i--)
                ans.push_back(matrix[i][left]);

            if (left++ >= right) break;
        }
        return ans;
    }
};
```





### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**题解**

维护跳的到的最远距离。

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
};
```



### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

**题解**

排序，依次合并。

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>> &intervals) {
        if (intervals.size() == 0) {
            return {};
        }
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> merged;
        for (int i = 0; i < intervals.size(); ++i) {
            int left = intervals[i][0], right = intervals[i][1];
            if (!merged.size() || merged.back()[1] < left) {
                merged.push_back({left, right});
            } else {
                merged.back()[1] = max(merged.back()[1], right);
            }
        }
        return merged;
    }
};
```



### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**题解**

按顺序模拟。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        // 创建二维矩阵
        vector<vector<int>> matrix(n, vector<int>(n));
        // 上下左右
        int top = 0;
        int bottom = n - 1;
        int left = 0;
        int right = n - 1;
        int num = 1;

        while (true) {
            // 由左到右
            for (int i = left; i <= right; i++)
                matrix[top][i] = num++;
            if (top++ >= bottom) break;
            // 由上到下
            for (int i = top; i <= bottom; i++)
                matrix[i][right] = num++;
            if (right-- <= left) break;
            // 由右到左
            for (int i = right; i >= left; i--)
                matrix[bottom][i] = num++;
            if (bottom-- <= top) break;
            // 由下到上
            for (int i = bottom; i >= top; i--)
                matrix[i][left] = num++;
            if (left++ >= right) break;
        }
        return matrix;
    }
};
```



### [69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

**题解**

二分。

```c++
class Solution {
public:
    int mySqrt(int x) {
        int left = 0, right = x, ans = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if ((long long) mid * mid <= x) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
};
```



### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

**题解**

记录最低价格，不断更新利润。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low=INT_MAX,ans=0;
        for(int i=0;i<prices.size();i++){
            low=min(prices[i],low);
            ans=max(ans,prices[i]-low);
        }
        return ans;
    }
};
```



### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

**题解**

若有唯一解，当我们从0行驶到N后，油表为非负。如果油表为负值就返回-1。

唯一出发点即为刚刚遍历过的油表最小值的地方，因为如果在该地出发，初始油表为 0，在遍历过程中没有位置会比该位置油表更低，也就不会低于 0，所以可以回到原地。

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
        //假设油箱里的汽油可以为负数，找到最小的负数就是出发点

        int n = gas.size();
        //默认从0出发
        int cur_gas = 0, min_gas = 0, min_index = 0;

        for (int i = 0; i < n; i++) {
            //走过了第i段路后邮箱里的油
            cur_gas = cur_gas + gas[i] - cost[i];
            if (cur_gas < min_gas) {
                min_gas = cur_gas;
                //这里i如果是n-1的话，说明当前汽油比0小，返回-1,不会返回错误的n。
                min_index = i + 1;
            }
        }

        //油箱为负值返回-1；
        return cur_gas < 0 ? -1 : min_index;
    }
};
```



### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**题解**

异或。

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans=0;
        for(int i=0;i<nums.size();i++){
            ans^=nums[i];
        }
        return ans;
    }
};
```



### [149. 直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)



我们可以考虑枚举所有的点，假设直线经过该点时，该直线所能经过的最多的点数。

假设我们当前枚举到点 ii，如果直线同时经过另外两个不同的点 jj 和 kk，那么可以发现点 ii 和点 jj 所连直线的斜率恰等于点 ii 和点 kk 所连直线的斜率。

于是我们可以统计其他所有点与点 ii 所连直线的斜率，出现次数最多的斜率即为经过点数最多的直线的斜率，其经过的点数为该斜率出现的次数加一（点 ii 自身也要被统计）。



**代码**

```c++
class Solution {
public:
    int gcd(int a, int b) {
        return b ? gcd(b, a % b) : a;
    }

    int maxPoints(vector<vector<int>> &points) {
        int n = points.size();
        if (n <= 2) {
            return n;
        }
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (ret >= n - i || ret > n / 2) {
                break;
            }
            unordered_map<int, int> mp;
            for (int j = i + 1; j < n; j++) {
                int x = points[i][0] - points[j][0];
                int y = points[i][1] - points[j][1];
                if (x == 0) {
                    y = 1;
                } else if (y == 0) {
                    x = 1;
                } else {
                    if (y < 0) {
                        x = -x;
                        y = -y;
                    }
                    int gcdXY = gcd(abs(x), abs(y));
                    x /= gcdXY, y /= gcdXY;
                }
                mp[y + x * 20001]++;
            }
            int maxn = 0;
            for (auto&[_, num]: mp) {
                maxn = max(maxn, num + 1);
            }
            ret = max(ret, maxn);
        }
        return ret;
    }
};
```



### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**题解**

投票法。

```c++
class Solution {
public:
    int majorityElement(vector<int> &nums) {
        int ans = nums[0], count = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] != ans)
                count--;
            else
                count++;
            if (count == 0) {
                ans = nums[i];
                count++;
            }

        }
        return ans;
    }
};
```



### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)



位运算。从 0 到 n 都异或一遍。同时对数组内数字异或一遍，

缺失的数字只异或了一次，其他的数都异或两次。

最后剩下缺失的数字。

**代码**

```c++
class Solution {
public:
    int missingNumber(vector<int> &nums) {
        int ans = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            ans ^= nums[i];
            ans ^= i;
        }
        ans ^= n;
        return ans;
    }
};
```



### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**题解**

双指针。

```c++
class Solution {
public:
    void moveZeroes(vector<int> &nums) {
        int slow = 0, fast = 0;
        while (fast < nums.size()) {
            if (nums[fast]) {
                swap(nums[slow], nums[fast]);
                slow++;
            }
            fast++;
        }
    }
};
```



### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

数学方法。

① 当所有绳段长度相等时，乘积最大。② 最优的绳段长度为 3 。

```c++
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 3)
            return n - 1;
        int a = n / 3, b = n % 3;
        //3 的倍数
        if (b == 0)
            return (int) pow(3, a);
        //模 3 余 1，
        if (b == 1)
            return (int) pow(3, a - 1) * 4;
        return (int) pow(3, a) * 2;
    }
};
```



### [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**题解**

1. 奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
2. 偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。

```c++
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> result(num+1);
        result[0] = 0;

        for(int i = 1; i <= num; i++){
            if(i % 2 == 1)
                result[i] = result[i-1] + 1;
            else
                result[i] = result[i/2];
        }
        return result;
    }
};
```





### [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)



根本不理解，直接背吧。

```c++
class Solution {
public:
    // 返回从prefix出发, 小于等于n的个数
    // 思路就是从位数考虑, 比如给出prefix = 45, n = 4566
    // 先考虑两位的情况(对答案的贡献), 即45 (等于46 - 45)
    // 在考虑三位的情况, 即450 ~ 459 (等于460 - 450)
    // 在考虑四位的情况, 即4500 ~ 4599 (等于std::min(4566 + 1, 4600) - 4500)
    long long get_count(long long prefix, long long n) {
        long long ret = 0, upper = prefix + 1;
        while (prefix <= n) {
            ret += std::min(n + 1, upper) - prefix;
            prefix *= 10;
            upper *= 10;
        }
        return ret;
    }

    long long findKthNumber(long long n, long long k) {
        // std::cout << get_count(45, 4566) << std::endl;
        // std::cout << get_count(1, 2) << std::endl;
        long long p = 1, prefix = 1;
        while (p < k) {
            long long cnt = get_count(prefix, n);
            if (p + cnt <= k) {
                // 将以prefix为根的子树遍历完都还小于等于k, 所以下一个遍历为prefix + 1
                p += cnt;
                prefix += 1;
            } else {
                // 以prefix为根的子树遍历完大于k, 所以答案一定在prefix为根的子树里, 所以往左走一步
                p += 1;
                prefix *= 10;
            }
        }
        return prefix;
    }
};
```



### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

**题解**

遍历到元素位置时，把该元素对应的下标位置取反，这样最后没有取反的就是结果。

```c++
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int> &nums) {
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            int index = abs(nums[i]) - 1;
            //如果大于零，取反
            if (nums[index] > 0) {
                nums[index] = -nums[index];
            }
        }
        for (int i = 0; i < nums.size(); i++) {
            //如果大于零，说明该位置缺失
            if (nums[i] > 0)
                ans.push_back(i + 1);
        }
        return ans;
    }
};
```



### [556. 下一个更大元素 III](https://leetcode-cn.com/problems/next-greater-element-iii/)

给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。

注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1 。

**题解**

首先倒序找到原数组中破坏递增的首个字符 a[i]，然后正序找到最小的大于 a[i] 的字符 a[j]，将两者位置进行调换。

然后将 a[i+1] 到最后的位置进行镜像交换，保证 a[i] 到最后保持最小。

```c++
class Solution {
public:
    int nextGreaterElement(int n) {
        string str = to_string(n);
        int len = str.size();
        // 如果只有1个，直接返回失败
        if (len <= 1) {
            return -1;
        }
        // 先找到最小的数字, 从n-2开始无必然有数字可以比较
        int i = len - 2;
        for (; i >= 0; --i) {
            if (str[i] < str[i + 1]) {
                break;
            }
        }

        // 数组已经是递增，则无法有更大数，返回失败
        if (i < 0) {
            return -1;
        }

        // 找到比 str[i] 稍大的 数字 str[j]
        int j = len - 1;
        for (; j >= 0; --j) {
            if (str[j] > str[i]) {
                break;
            }
        }
        swap(str[i], str[j]);

        // 翻转从i+1到end 的数组
        reverse(str.begin() + i + 1, str.end());

        // 考虑int溢出的情况
        long res = stol(str);
        return res > INT_MAX ? -1 : res;
    }
};
```



### [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

**题解**

贪心，支付十块的就找五块，支付 20 的就优先找 10 块 + 5 块，其次找 3 张 5 块。

如果找零失败，返回 false。

```c++
class Solution {
public:
    bool lemonadeChange(vector<int> &bills) {
        int five = 0, ten = 0;
        for (int i = 0; i < bills.size(); i++) {
            if (bills[i] == 5) {
                five++;
            } else if (bills[i] == 10) {
                if (five == 0) {
                    return false;
                }
                five--;
                ten++;
            } else {
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
};
```



### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**题解**

数学方法。

① 当所有绳段长度相等时，乘积最大。② 最优的绳段长度为 3 。

```c++
class Solution {
public:
    int cuttingRope(int n) {
        if (n <= 3)
            return n - 1;
        int a = n / 3, b = n % 3;
        //3 的倍数
        if (b == 0)
            return (int) pow(3, a);
        //模 3 余 1，
        if (b == 1)
            return (int) pow(3, a - 1) * 4;
        return (int) pow(3, a) * 2;
    }
};
```



### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**题解**

魔改归并，当左边大于右边时统计 cnt。

```c++
class Solution {
    int cnt;
    //辅助数组，用于归并
    vector<int> temp;
public:
    int reversePairs(vector<int> &nums) {
        temp.resize(nums.size());
        sort(nums, 0, nums.size() - 1);
        return cnt;
    }

    void sort(vector<int> &nums, int left, int right) {
        int mid = left + ((right - left) >> 1);
        if (left < right) {
            sort(nums, left, mid);
            sort(nums, mid + 1, right);
            merge(nums, left, mid, right);
        }
    }

    void merge(vector<int> &nums, int left, int mid, int right) {
        //确定左序列和右序列的开始位置，使用 idx 同步修改辅助数组中的值
        int leftIdx = left, rightIdx = mid + 1, idx = left;
        //合并
        while (leftIdx <= mid && rightIdx <= right) {
            //相较归并排序的改变，相等时不增加 cnt
            if (nums[leftIdx] <= nums[rightIdx]) {
                temp[idx] = nums[leftIdx];
                leftIdx++;
            } else {
                //这里增加 cnt
                cnt += (mid - leftIdx + 1);
                temp[idx] = nums[rightIdx];
                rightIdx++;
            }
            idx++;
        }
        //合并两序列中剩余元素
        while (leftIdx <= mid) {
            temp[idx] = nums[leftIdx];
            idx++;
            leftIdx++;
        }
        while (rightIdx <= right) {
            temp[idx] = nums[rightIdx];
            idx++;
            rightIdx++;
        }
        //将辅助数组里的内容保存到主数组中
        for (int i = left; i <= right; ++i) {
            nums[i] = temp[i];
        }
    }
};
```





### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

**题解**

数学推论。

`dp[i] = (dp[i - 1] +m) % i`

```c++
class Solution {
public:
    int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
};
```



### [剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode-cn.com/problems/xx4gT2/)

小根堆

```c++
class Solution {
public:
    int findKthLargest(vector<int> &nums, int k) {
        priority_queue<int, vector<int>, greater<int>> minHeap;
        for (int i = 0; i < nums.size(); i++) {
            if (minHeap.size() < k) {
                minHeap.push(nums[i]);
            } else if (nums[i] > minHeap.top()) {
                minHeap.pop();
                minHeap.push(nums[i]);
            }
        }
        return minHeap.top();
    }
};
```

快速选择，找第 k + 1 小

```c++
class Solution {
public:
    int findKthLargest(vector<int> &nums, int k) {
        if (k == 0 || nums.size() == 0)
            return 0;
        //第 n 大，则为第 n + 1 小
        quickSelect(nums, 0, nums.size() - 1, nums.size() - k + 1);
        //第k大的所在的位置
        return nums[nums.size() - k];
    }

    //快速选择，遇到返回的位置
    void quickSelect(vector<int> &nums, int left, int right, int k) {
        if (left >= right)
            return;
        //idx 为分割后的 pivot 位置
        int idx = partition(nums, left, right);
        //len 为刚刚一趟分割后 pivot 左边的序列长度
        int len = idx - left + 1;
        if (len == k) {
            return;
        } else if (k < len)
            //需要的比分割好的小，说明分割的粒度太粗，重新往小了分割
            return quickSelect(nums, left, idx - 1, k);
        else
            //需要的比分割好的大，说明分割的不够，重新往大了分割
            return quickSelect(nums, idx + 1, right, k - len);
    }

    //随机锚点分割函数，返回 pivot 在数组中的位置
    int partition(vector<int> &nums, int left, int right) {
        //随机锚点
        int randomIndex = left + 1 + rand() % (right - left);
        swap(nums[left], nums[randomIndex]);

        int pivot = left, slow = pivot + 1;
        for (int fast = slow; fast <= right; fast++) {
            if (nums[fast] < nums[pivot]) {
                swap(nums[fast], nums[slow]);
                slow++;
            }
        }
        swap(nums[pivot], nums[slow - 1]);
        return slow - 1;
    }
};
```



### [面试题 10.01. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

**题解**

利用双指针法。我们知道如果从头开始，那么数组 A 的元素会被覆盖，那么我们可以从后面开始。

```c++
class Solution {
public:
    void merge(vector<int>& A, int m, vector<int>& B, int n) {
        int pa = m - 1, pb = n - 1;
        int tail = m + n - 1;
        int cur;
        while (pa >= 0 || pb >= 0) {
            if (pa == -1) {
                cur = B[pb--];
            } else if (pb == -1) {
                cur = A[pa--];
            } else if (A[pa] > B[pb]) {
                cur = A[pa--];
            } else {
                cur = B[pb--];
            }
            A[tail--] = cur;
        }
    }
};
```



### 求平方根

（这道题目跟 leetcode 上的不一样，leetcode 上只要求整数，这个还有精度） 写一个函数，求平方根，函数参数为目标数字和精度，测试案例 fn(4.1,0.001) fn(501.1,0.001) fn(0.045,0.001)

**题解**

使用二分法

```c++
class Solution {
public:
    double fn(float n, float e) {
        // 先求 e 的精度
        string d = to_string(e);
        int len = d.size() - 2;
        double x = 0;
        if (n > 0 && e > 0) {
            double left = 0;
            double right = n;
            while (left < right) {
                // 二分，并控制精度
                stringstream stream;
                stream << ((left + right) / 2) << "." << len << "f";

                double mid = atof(stream.str().c_str());
                if (mid * mid < n - e) {
                    left = mid;
                } else if (mid * mid > n + e) {
                    right = mid;
                } else {
                    x = mid;
                    break;
                }
            }
        }
        return x;
    }
};
```



### 求出反转的数字对



遇到这种求左右两边相等的题，首先想到归项，将 i 和 j 归到一边，以满足一次遍历就能找到答案。

归项得 nums[i] - rev(nums[i]) = nums[j] - rev(nums[j])。

用 map 保存出现的次数。

**代码**

```c++
class Solution {
public:
    int solve(vector<int> &nums) {
        map<int, int> map;
        int cnt = 0, MOD = 1e9 + 7;
        for (int i = 0; i < nums.size(); ++i) {
            int temp = nums[i] - rev(nums[i]);
            //map中保存的是已经出现了多少次该值，就相当于与新的值结成了多少对
            cnt = (cnt + map[temp]) % MOD;
            map[temp]++;
        }
        return cnt;
    }

    int rev(int num) {
        int ret = 0;
        while (num != 0) {
            ret = ret * 10 + num % 10;
            num /= 10;
        }
        return ret;
    }
};
```



### 数组中最后负数与最前正数



题目中描述的数组，求解结果是与0比较的，可以看做是有序的，分别二分查找，时间复杂度可以达到log(n)

**代码**

```c++
vector<int> BinSearch(vector<int> &nums) {
    if (nums.empty() || nums[0] >= 0 || nums[nums.size() - 1] <= 0)
        return {-1, -1};
    int positive = 0, negative = 0, mid, left = 0, right = nums.size() - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (nums[mid] >= 0)
            right = mid - 1;
        else
            left = mid + 1;
    }
    vector<int> ans;
    ans.push_back(nums[right]);
    right = nums.size() - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (nums[mid] <= 0)
            left = mid + 1;
        else
            right = mid - 1;
    }
    ans.push_back(nums[left]);
    return ans;
}
```



### 有序数组中不重复元素的个数

给定一个有序数组，请算出平方后的结果可能的个数。

**题解**

双指针，一个从前往后，一个从后往前。

```c++
class Solution {
public:
    int countElements(vector<int> &nums) {
        if (nums.size() == 0) {
            return 0;
        }
        if (nums.size() == 1) {
            return 1;
        }
        //将所有负数转正
        for (int i = 0; i < nums.size(); i++) {
            nums[i] = abs(nums[i]);
        }
        int head = 0, tail = nums.size() - 1;
        //上一个数据
        int lastBig = -1;
        //不一样的数的个数
        int count = 0;
        //注意这里是小于等于
        while (head <= tail) {
            while (head < nums.size() && nums[head] == lastBig) {
                head++;
            }
            while (tail >= 0 && nums[tail] == lastBig) {
                tail--;
            }
            if (head <= tail) {
                count++;
                if (nums[head] > nums[tail]) {
                    lastBig = nums[head];
                    head++;
                } else {
                    lastBig = nums[tail];
                    tail--;
                }
            } else {
                return count;
            }
        }
        return count;
    }
};
```



### 找出不重复的元素个数

一个数据先递增再递减，找出数组不重复的个数。不能使用额外空间，复杂度o(n)

**题解**

显然要先找到最大元素的位置，然后朝两边移动。

```c++
class Solution {
public:
    int countElements(vector<int> &nums) {
        int ans = 0;
        // 找到最大的数
        int maxIndex = 0;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] < nums[i - 1]) {
                maxIndex = i - 1;
                break;
            }
        }
        ans++;
        // 找到左右两指针开始的位置
        int left = maxIndex - 1, right = maxIndex + 1;
        while (left - 1 >= 0 && nums[left] == nums[maxIndex]) left--;
        while (right + 1 < nums.size() && nums[right] == nums[maxIndex]) right++;
        // 开始比较
        int temp = nums[maxIndex] + 1;
        while (left >= 0 && right < nums.size()) {
            if (nums[left] == nums[right]) {
                if (nums[left] != temp) {
                    ans++;
                    temp = nums[left];
                }
                left--;
                right++;
            } else if (nums[left] < nums[right]) {
                ans++;
                right++;
            } else {
                ans++;
                left--;
            }
        }
        return ans;
    }
};
```



### 找出重复元素

1亿个正整数,范围是0-42亿。求出现次数是2的数字。

**题解**

这道题没有说是否只有一个次数为 2 的数字，也没有说其他数字出现的次数，因此就把题目看成是有多个出现次数为 2 的数字，并且其他数字只会出现一次。 使用位图法来做。

位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。



```c++
class Solution {
public:

    vector<int> findDuplicated(vector<int> &nums) {
        vector<int> ans;
        int upper = INT_MIN;
        int lower = INT_MAX;
        // 这边是先遍历了一遍，找到数据中的最小值和最大值，从而减小位图法中数组的长度
        for (int i = 0; i < nums.size(); i++) {
            upper = max(upper, nums[i]);
            lower = min(lower, nums[i]);
        }
        //位图
        int len = upper / 8 - lower / 8 + 1;
        vector<unsigned char> bitmap(len);
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            int index = num / 8 - lower / 8;
            int k = (num - lower) % 8;
            if ((bitmap[index] & 1 << k) > 0) {
                ans.push_back(num);
            } else {
                bitmap[index] |= (1 << k);
            }
        }
        return ans;
    }
};
```



### 小于 n 的最大数

给定一个数 n 如 23121，给定一组数字 a 如 {2,4,9}。

求 a 中元素组成的、小于 n 的最大数，如小于 23121 的最大数为 22999。

**题解**

直接做

```c++
class Solution {
public:
    int minNum(int target, vector<int> &nums) {
        string ans;
        sort(nums.begin(), nums.end());
        string str = to_string(target);
        bool flag = false;
        for (int i = 0; i < str.size(); i++) {
            if (flag) {
                ans.push_back('0' + nums[nums.size() - 1]);
                continue;
            }
            int j = 0;
            while (j < nums.size() && nums[j] <= str[i] - '0') {
                j++;
            }
            if (nums[j - 1] < str[i] - '0')
                flag = true;
            ans.push_back('0' + nums[j - 1]);
        }
        return stoi(ans);
    }
};
```

