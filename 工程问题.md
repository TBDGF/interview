## 跨域请求

[一文搞懂跨域的所有问题，生活从此669~ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/66484450)

- 客户端浏览器解除跨域限制（理论上可以但是不现实）
- 发送JSONP请求替代XHR请求（并不能适用所有的请求方式，不推荐）
- 修改服务器端（包括HTTP服务器和应用服务器）（**推荐**）

**我的实现**

服务器加上

```
"Access-Control-Allow-Origin" : "*"
"Access-Control-Allow-Methods" : "*"
"Access-Control-Allow-Headers" : "*"
```



## 异地登录检测

[防止同一用户在不同地方下登陆的简单实现_Junio_2014的专栏-CSDN博客](https://blog.csdn.net/Junio_2014/article/details/80695644)



## 中间件

**Gin中间件**

[Gin框架入门(四)—中间件_Samdom的博客-CSDN博客_gin 中间件](https://blog.csdn.net/weixin_36162966/article/details/91383006)

**什么是中间件**

说的绝对一点，在业务场景下，与业务无关的都是中间件。包括数据库、离线等。

**中间件的好处**

系统开发更简单 ， 基于成熟的组件来做，可以极大减少技术选择成本。



## Redis 实现乐观锁

乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

在 Redis 中，我们可以通过事务 + Watch 的方式来实现乐观锁。在用户使用 WATCH 命令监视某个键之后，直到该用户执行 EXEC 命令的这段时间里，如果有其他用户抢先对被监视的键进行了替换、更新、删除等操作，那么当用户尝试执行 EXEC 的时候，事务将失败并返回一个错误，用户可以根据这个错误选择重试事务或者放弃事务。

```go
func (c *Client) Watch(fn func(*Tx) error, keys ...string) error
```

watch 的第一个参数是一个返回 error 的 支持事务的函数，watch 会向该函数中传递事务对象。

我们在该函数中对该事务对象调用 TxPipelined，它内部会使用`MULTI/EXEC`包裹排队的命令。

```go
func (c *Tx) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error)
```

