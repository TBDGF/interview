## 引擎的区别

**MyISAM**

创建一个myisam存储引擎的表的时候回出现三个文件

1.tb_demo.frm，存储表定义； 2.tb_demo.MYD，存储数据； 3.tb_demo.MYI，存储索引。

MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。

MyISAM存储引擎特别适合在以下几种情况下使用：

1.选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。

2.插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。

 

**InnoDB**

InnoDB是一个健壮的事务型存储引擎MySQL 5.6.版本以后InnoDB就是作为默认的存储引擎。

InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：

1. 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
2. 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
3. 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
4. 外键约束。MySQL支持外键的存储引擎只有InnoDB。
5. 支持自动增加列AUTO_INCREMENT属性。

 

**MEMORY**

使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。

一般在以下几种情况下使用Memory存储引擎：

1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。

2.如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。

3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中

 

**MERGE**

MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。Merge存储引擎的使用场景。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。

 

**ARCHIVE**

archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。

 

比较常用的是MyISAM和InnoBD

|                                        | **MyISAM**                                                   | **InnoDB**                                                   |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **构成上的区别：**                     | 每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。<br />.frm文件存储表定义。<br />数据文件的扩展名为.MYD (MYData)。<br />索引文件的扩展名是.MYI (MYIndex)。 | 基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB |
| **事务处理上方面:**                    | MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持 | InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能 |
| **SELECT  UPDATE, INSERT，Delete操作** | 如果执行大量的SELECT，MyISAM是更好的选择                     | **1.**如果你的数据执行大量的**INSERT** **或** **UPDATE**，出于性能方面的考虑，应该使用InnoDB表   <br />**2.DELETE  FROM table**时，InnoDB不会重新建立表，而是一行一行的删除。<br />**3.LOAD  TABLE FROM MASTER**操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用 |
| **对AUTO_INCREMENT 的操作**            | 每表一个AUTO_INCREMEN列的内部处理。<br />**MyISAM** **为** **INSERT** **和** **UPDATE** **操作自动更新这一列**。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置   对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引   更好和更快的auto_increment处理 | 如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。<br />自动增长计数器仅被存储在主内存中，而不是存在磁盘上<br />关于该计算器的算法实现，请参考   **AUTO_INCREMENT** **列在** **InnoDB** **里如何工作** |
| **表的具体行数**                       | select count(*) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的 | InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行 |
| **锁**                                 | 表锁                                                         | 提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “�a%” |





## 事务的特性（ACID）

如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：

**⑴ 原子性（Atomicity）**

原子性指整个数据库事务是不可分割的单位，只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个 SQL 语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

**⑵ 一致性（Consistency）**

一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。完整性包含实体完整性（主属性不为空）、参照完整性（外键必须存在原表中）、用户自定义的完整性。

**⑶ 隔离性（Isolation）**

事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交对其他事务都不可见，通常这使用锁来实现。数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止**多个事务并发执行时由于交叉执行而导致数据的不一致**。

**⑷ 持久性（Durability）**

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



## 事务的实现

隔离性通过 MVCC 和锁来实现。这其中 MVCC 又有 undo log 的参与。

原子性、一致性、持久性通过数据库的 redo log 和 undo log 来完成。redo log 称为重做日志，用来保证事务的持久性。undo log 用来保证事务的原子性。

redo 和 undo 的作用都可以视为是一种恢复操作，redo 恢复提交事务修改的页操作，而 undo 回滚行记录到某个特定版本。redo 通常是物理日志，记录的是页的物理修改操作。undo 是逻辑日志，根据每行记录进行记录。

redo log 用来保证持久性，undo log 用来实现原子性及 MVCC 的功能。



### redo

重做日志用来实现事务的持久性，即事务 ACID 中的 D。

当事务提交时（COMMIT）时，必须先将事务的所有日志写入到重做日志文件（redo log file）中来持久化。这里的日志包括 undo log 和 redo log，因为 undo log 也依赖于 redo log 来持久化。



**binlog**

binlog 用来进行 POINT-IN-TIME（PIT）的恢复及主从复制（Replication）环境的建立。

- 重做日志在 InnoDB 储存引擎层产生，而二进制日志是在 MySQL 数据库 的上层产生的，并且二进制日志不仅仅针对于 InnoDB 储存引擎，MySQL 数据库中的任何储存引擎对于数据库的更改都会产生 binlog。
- 两种日志记录的内容形式不同。MySQL 数据库上层的二进制日志是是一种逻辑日志，其记录的是对应的 SQL 语句。而 InnoDB 存储引擎层面的重做日志是物理格式日志，其记录的是对每个页的修改。
- 两种日志记录写入磁盘的时间点不同，二进制日志只在事务提交完成后进行一次写入。而 InnoDB 存储引擎的重做日志在事务进行中不断地被写入，这表现为日志并不是随事务提交的顺序进行写入的。



### undo

undo log 来保证原子性和辅助 MVCC。

对数据库的每一条数据的改动（INSERT、DELETE、UPDATE）都会在 undo log 中记录一条相反的记录。undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。

当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过 undo log 来实现的：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。

另外，undo log 也会产生 redo log，因为 undo log 也要实现持久性保护。



## 隔离级别

**若不考虑隔离性**

 1.**脏读**

脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。

2.**不可重复读**

不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。

3.**幻读**

指一个事务执行两次查询，但第二次查询的结果包含了第一次查询中未出现的数据。

例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

4.**丢失更新**

指两个事务同时更新一行数据，后提交（或撤销）的事务将之前事务提交的数据覆盖了。

丢失更新可分为两类，分别是第一类丢失更新和第二类丢失更新。

- 第一类丢失更新是指两个事务同时操作同一个数据时，当第一个事务撤销时，把已经提交的第二个事务的更新数据覆盖了，第二个事务就造成了数据丢失。
- 第二类丢失更新是指当两个事务同时操作同一个数据时，第一个事务将修改结果成功提交后，对第二个事务已经提交的修改结果进行了覆盖，对第二个事务造成了数据丢失。

### **隔离级别**

1.**读未提交（Read uncommitted）**

这种事务隔离级别下，select语句不加锁。

此隔离级别可防止丢失更新。

2.**读已提交（Read committed）**

可避免 脏读 的发生。

3.**可重复读（Repeatable read）**

MySql默认隔离级别。

可避免 脏读 、不可重复读 的发生。

4.**串行化（Serializable ）**

可避免 脏读、不可重复读、幻读 的发生。

### 锁

- Shared Locks(共享锁/S锁)：允许事务读一行数据
- 若事务 T 对数据对象 A 加上 S 锁，则事务 T 只能读 A ；其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A ，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。
  - 即 S-S 兼容，其他互斥

- Exclusive Locks（排他锁/X锁）：允许事务删除或更新一行数据
  - 若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A ，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作( INSERT、UPDATE 或 DELETE )过程中始终应用排它锁。
  - X 锁与任何锁都不兼容


| 行级 |   X    |   S    |
| :--: | :----: | :----: |
|  X   | 不兼容 | 不兼容 |
|  S   | 不兼容 |  兼容  |



- Intention locks（意向锁）：
  - **意向锁是一种快速判断表锁与之前可能存在的行锁冲突的机制**
  - 如果想对某个记录 r 上 X 锁，那么需要分别对数据库 A 、表、页上意向锁 IX，最后才能对记录 r 上 X 锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。
  - 意向锁为表级别的锁：
    - 意向共享锁（ IS Lock），事务想要获得一张表中某几行的共享锁。
    - 意向排他锁（ IX Lock），事务想要获得一张表中某几行的排他锁。
  - 由于 InnoDB 储存引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。**IX，IS 是表级锁，不会和行级的 X，S 锁发生冲突。只会和表级的 X，S 发生冲突。**行级别的 X 和 S 按照普通的共享、排他规则即可。

| 表级 |   IS   |   IX   |   S    |   X    |
| :--: | :----: | :----: | :----: | :----: |
|  IS  |  兼容  |  兼容  |  兼容  | 不兼容 |
|  IX  |  兼容  |  兼容  | 不兼容 | 不兼容 |
|  S   |  兼容  | 不兼容 |  兼容  | 不兼容 |
|  S   | 不兼容 | 不兼容 | 不兼容 | 不兼容 |



- Record Locks（行锁）：

  - 行锁，顾名思义，是加在`索引行`(对！是索引行！不是数据行！)上的锁。比如`select * from user where id=1 and id=10 for update`，就会在`id=1`和`id=10`的索引行上加Record Lock。
  - `id` 列必须为`唯一索引列`或`主键列`，加的锁就会变成`临键锁`。

- Gap Locks（间隙锁）：

  间隙锁，它会锁住两个索引之间的区域。比如`select * from user where id>1 and id<10 for update`，就会在id为(1,10)的索引区间上加Gap Lock。

- Next-Key Locks(间隙锁)：

  也叫间隙锁，它是Record Lock + Gap Lock形成的一个闭区间锁。比如`select * from user where id>=1 and id<=10 for update`，就会在id为[1,10]的索引闭区间上加Next-Key Lock。



**什么时候加锁**

在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:

- select: 即最常用的查询，是不加任何锁的
- select ... lock in share mode: 会加共享锁(Shared Locks)
- select ... for update: 会加排它锁



### 一致性读

#### 一致性非锁定读

MVCC的全称是“多版本并发控制”。这项技术使得InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值。这是一个可以用来增强并发性的强大的技术，因为这样的一来的话查询就不用等待另一个事务释放锁。

如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会因此去等待行上锁的释放，而是会去读取行的一个快照数据。

通过这种方式完成的读取被称为一致性非锁定读，因为不需要等待访问的行上 X 锁的释放。快照数据是指该行的之前的版本的数据，该实现是通过 undo 段来完成。而 undo 用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。

在 RC 事务隔离级别下，对于快照数据，非一致性锁定读总是读取被锁定行的最新一份快照数据，即每次 SELECT 都会读取最新的快照。而在 RR 事务隔离级别下，对于快照数据，非一致性锁定读总是读取事务创建 TRX 结构时的行数据版本，即第一次 SELECT 时的快照数据。

InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。

> 在Mysql中MVCC是在Innodb存储引擎中得到支持的，Innodb为每行记录都实现了三个隐藏字段：
>
> 6字节的事务ID（DB_TRX_ID）
>
> 7字节的回滚指针（DB_ROLL_PTR）
>
> 隐藏的ID（DB_ROW_ID）
>
> 6字节的事物ID用来标识该行所属的事务，7字节的回滚指针需要了解下Innodb的事务模型。

**增删查改**

在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。

于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：

- SELECT
  - 读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
- INSERT
  - 将当前事务的版本号保存至行的创建版本号
- UPDATE
  - 新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
- DELETE
  - 将当前事务的版本号保存至行的删除版本号



#### 一致性锁定读

InnoDB 储存引擎对于 SELECT 语句支持两种一致性的锁定读（ locking read ）操作：

- SELECT ... FOR UPDATE ，对读取的行记录加一个 X 锁，其他事务不能对已锁定的行上加上任何锁。
- SELECT ... LOCK IN SHARE MODE ，对读取的行记录加一个 S 锁，其他事务可以向被锁定的行加 S 锁，但是如果加 X 锁，则会被阻塞。



### 锁的算法

- Record Lock ：单个行记录上的锁，总是会去锁住索引记录。
- Gap Lock ：间隙锁，锁定一个范围，但不包含记录本身。
- Next-Key Lock ：Gap Lock + Record Lock ，锁定一个范围，并且锁定记录本身，范围通常为左开右闭区间。

InnoDB 对于行的查询都是采用这种锁定算法的。

当查询的索引含有唯一属性时，InnoDB 储存引擎会对 Next-Key Lock 进行优化，将其降级为 Record Lock ，即仅锁住索引本身，而不是范围。

通过唯一索引来锁定不存在的值，也会产生区间锁定。

如果查找的记录没有索引时，会锁全表。



**辅助索引**

如果使用辅助索引进行一致性锁定读，因为有两个索引，所以需要分别锁定。

- 对于聚集索引，仅对该辅助索引条件下对应的聚集索引行加上 Record Lock 。
- 对于辅助索引，其加上的是 Next-Key Lock 。



由此可见，Gap Lock 的作用是为了阻止多个事务将记录插入到同一范围内，这防止了幻读的产生。



### 实现原理

**读未提交（READ UNCOMMITTED）**

事务之间可以读取彼此未提交的数据。

`READ UNCOMMITTED`隔离级别下, 读不会使用一致性非锁定读。

写会加排他锁，并到事务结束之后释放。



**读已提交（Read committed）**

事务之间可以读取彼此已提交的数据。

读采取一致性非锁定读。每次 select 会通过**MVCC**获取当前数据的**最新**快照，以此**解决脏读**。但是会在每次 select 时生成新的快照版本，会引起不可重复读的问题。

写加排他锁。



**可重复读（Repeatable read）**

读采用一致性非锁定读，在事务创建 TRX 结构时（第一次 select 时）生成版本，后续的查询都是在这个版本上进行，从而避免了不可重复读。

写加排他锁。

此时如果事务中都使用快照读或者当前读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。

- 都使用快照读：每次都是在同一个版本上进行查询，结果不会有改变
- 都使用当前读：当前读会加上 Next-Key Lock ，阻塞查询区间内其他事务的修改，结果也不会有改变



**串行化（Serializable）**

大杀器，该级别下，会自动将所有普通`select`转化为`select ... lock in share mode`执行，即针对同一数据的所有读写都变成互斥的了，可靠性大大提高，并发性大大降低。

读-写，写-写均互斥。



## 死锁

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。若无外力作用，事务就无法推进下去。

解决死锁最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。若超时的事务权重比较大，回滚的时间甚至可能相对另一个事务所占用的时间多很多。

除了超时机制，当前数据库还都普遍采用 wait-for-graph（等待图）的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。



### wait-for-graph

wait-for-graph 要求数据库保存以下两种信息：

- 锁的信息链表
- 事务等待链表

通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。

在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说 InnoDB 会选择回滚 undo 量最小的事务。









## 索引分类

- 普通索引：用表中的普通列构建的索引，没有任何限制，用于加速查询
- 唯一索引：用来建立索引的类的值必须是唯一的，允许空值
  - 关键字：unique
  - 语法：create unique 索引名 on 表名(字段名);
  - 唯一约束的作用：列值不能重复，但是允许null；当给某个列添加唯一约束，会自动添加唯一索引
  - 约束：限制列的动作，包括添加修改值

- 主键索引：
  - 即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值，是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。当列添加主键约束时，自动添加主键索引。

- 组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值
  - 语法：create index 索引名 on 表名(字段1,字段2);

- 全文索引：用大文本对象的列构建的索引，主要用来查找文件中的关键字。
  - 关键字：fulltext
  - 语法：create fulltext index 索引名 on 表名(字段名);



## 聚集索引与非聚集索引

- 聚集索引
  - 主键索引
- 非聚集索引
  - 普通索引
  - 唯一索引
  - 联合索引



**聚集索引**

> 定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

索引的叶子节点就是对应的数据节点，可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询。



**非聚集索引**

> 定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

其实按照定义，除了聚集索引以外的索引都是非聚集索引，例如普通索引，唯一索引，全文索引。

非聚集索引通常指向主键，所以如果查询主键之外的数据，通常要通过聚集索引再次查询。



## 索引结构

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

### B树

B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡多路查找树。下图就是一个典型的B树： 
![这里写图片描述](https://img-blog.csdn.net/20160926140212457)

详细定义：

> 1. 有一个根节点，根节点只有一个记录和两个孩子或者根节点为空；
> 2. 每个节点记录中的key和指针相互间隔，指针指向孩子节点；
> 3. d是表示树的宽度，除叶子节点之外，其它每个节点有[d/2,d-1]条记录，并且些记录中的key都是从左到右按大小排列的，有[d/2+1,d]个孩子；
> 4. 在一个节点中，第n个子树中的所有key，小于这个节点中第n个key，大于第n-1个key，比如上图中B节点的第2个子节点E中的所有key都小于B中的第2个key 9，大于第1个key 3;
> 5. 所有的叶子节点必须在同一层次，也就是它们具有相同的深度；

由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：

```kotlin
BTree_Search(node, key) {
     if(node == null) return null;
     foreach(node.key){
          if(node.key[i] == key) return node.data[i];
          if(node.key[i] > key) return BTree_Search(point[i]->node);
      }
     return BTree_Search(point[i+1]->node);
  }
data = BTree_Search(root, my_key);
```

关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为`logd((N+1)/2)`，检索一个key，其查找节点个数的渐进复杂度为`O(logdN)`。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。

另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以查阅其它文献进行详细研究。



### **B+树**

其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。B-Tree相比，B+Tree有以下不同点：

- 每个节点的指针上限为2d而不是2d+1；
- 内节点不存储data，只存储key；
- 叶子节点不存储指针；

下面是一个简单的B+Tree示意。 

![这里写图片描述](https://img-blog.csdn.net/20160926140413000)

由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。

**带有顺序访问指针的B+Tree**

一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。 
![这里写图片描述](https://img-blog.csdn.net/20160926140641162)

如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

### InnoDB B+树

InnoDB的数据文件本身就是索引文件。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 

![这里写图片描述](https://img-blog.csdn.net/20160926141856136)

上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。



InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引： 

![这里写图片描述](https://img-blog.csdn.net/20160926141926745)

这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

**联合索引**

- 对于联合索引来说只不过比单值索引多了几列。
- 联合索引的所有索引列都出现在索引树上，并依次顺序比较几个列的大小。
- InnoDB引擎会首先根据第一个索引列“单调递增”排序，如果第一列相等则再根据第二列排序，依次类推.

(b,c,d) 联合索引的所有索引列都出现在索引数上，并依次比较b,c,d三列的大小。

![bcd联合索引在B+树上的结构图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8yLzI3LzE3MDg2N2NiNmFmMGE3MmQ?x-oss-process=image/format,png)

### 为什么不用红黑树或是B树

**红黑树**

1.红黑树必须存在内存里的，数据库表太大了，存不进去。

2.即使你找到了把红黑树存进硬盘的方法，红黑树查找一个节点最多要查logN层，每一层都是一个内存页（虽然你只是想找一个节点，但硬盘必须一次读一个页。。），那么一共logN次IO。

所以需要用b+树减少树的高度

**B树**

1.b树的内部节点都是存储实际数据的，比如一个节点是一个页4096字节，其中每条数据128字节，那么一个节点只能存32个数据项，那么对应的孩子节点数最多为33个，这显然不够用。而b+树内部节点只作为导向作用，只存一个整数就可以，4096/4=1024个数据项。这样b+树的每个节点的孩子数更多，整个树的高度就更低，大大增加查询效率。

2.b+树的叶子节点可以有链表相连，适合范围查询，因为相邻页直接读取就好了。但b树做不到这一点。





## 索引的结构优化

**联合索引（复合索引）**

首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：

- 第一个字段一定是有序的

- 当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的

  | A | B | C | 
  | 1 | 2 | 3 | 
  | 1 | 4 | 2 | 
  | 1 | 1 | 4 | 
  | 2 | 3 | 5 | 
  | 2 | 4 | 4 | 
  | 2 | 4 | 6 | 
  | 2 | 5 | 5 |

其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。

**最左前缀原理**

我们再来详细介绍一下联合索引的查询。还是上面例子，我们在`（a,b,c）`字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：

以下的查询方式都可以用到索引

```sql
select * from table where a=1；
select * from table where a=1 and b=2；
select * from table where a=1 and b=2 and c=3；
```

上面三个查询按照 `（a ）, （a，b ）,（a，b，c ）`的顺序都可以利用到索引，这就是最左前缀匹配。

如果查询语句是：

```sql
select * from table where a=1 and c=3； 那么只会用到索引a。
```

如果查询语句是：

```sql
select * from table where b=2 and c=3； 因为没有用到最左前缀a，所以这个查询是用户到索引的。
```

如果用到了最左前缀，但是顺序颠倒会用到索引码？

比如：

```sql
select * from table where b=2 and a=1；
select * from table where b=2 and a=1 and c=3；
```

如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。

**前缀索引**

除了联合索引之外，对mysql来说其实还有一种前缀索引。前缀索引就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

一般来说以下情况可以使用前缀索引：

- 字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’
- 字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。
- 前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。

一些文章中也提到：

MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。

**策略**

- 最左前缀匹配原则，上面讲到了
- 主键外键一定要建索引
- 对 where,on,group by,order by 中出现的列使用索引
- 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0
- 对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键
- 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
- 为较长的字符串使用前缀索引
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
- 不要过多创建索引, 权衡索引个数与DML之间关系，DML也就是插入、删除数据操作。这里需要权衡一个问题，建立索引的目的是为了提高查询效率的，但建立的索引过多，会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建
- 对于like查询，”%”不要放在前面。 
  `SELECT * FROM`houdunwang`WHERE`uname`LIKE'后盾%' -- 走索引` 
  `SELECT * FROM`houdunwang`WHERE`uname`LIKE "%后盾%" -- 不走索引`
- 查询where条件数据类型不匹配也无法使用索引 
  字符串与数字比较不使用索引; 
  `CREATE TABLE`a`(`a`char(10));` 
  `EXPLAIN SELECT * FROM`a`WHERE`a`="1"` – 走索引 
  EXPLAIN SELECT * FROM `a` WHERE `a`=1 – 不走索引 
  正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因



## 索引失效

[索引失效的7种情况 - liehen2046 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liehen2046/p/11052666.html)

1.有or必全有索引;

2.复合索引未用左列字段;

3.like以%开头;

4.需要类型转换;

5.where中索引列有运算;

6.where中索引列使用了函数;

7.如果mysql觉得全表扫描更快时（数据少）;



## SQL题

[经典SQL练习题(MySQL版)_廖致君的博客-CSDN博客_mysql练习](https://blog.csdn.net/paul0127/article/details/82529216)
