## 面向对象



**面向对象的优点**

- 提高了代码的可扩展性。
- 提高了代码的可维护性。
- 面向对象的封装，继承，多态。



**面向对象的特征**

- 封装：封装是把对象的属性和实现细节隐藏起来，仅对外提供公共的访问方法（这些对象通过一个受保护的接口访问其他对象）。

- 继承：多个类中存在相同的属性和行为时，将这些相同的内容抽取到一个单独的类中，那么多个类无需再定义这些属性和行为，只要继承这个类即可，继承这个类的为新类，新类称为原始类的派生类（子类）而原始类称为新类的基类（父类）。派生类可以从它的基类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。可通过extends关键字实现继承。

- 多态：多态性是指允许不同类的对象对同一消息作出响应，多态性语言具有灵活，抽象，行为共享，代码共享的优势，很好解决了应用程序函数同名的问题。

  例子：可以将 ArrayList 或 LinkedList 实例化到 List 对象上并操作。



**继承和多态的区别**

继承是子类获得父类的成员，重写是继承后重新实现父类的方法。重载是在一个类里一系列 参数不同 名字相同 的方法。

多态则是为了避免在父类里大量重载引起代码臃肿且难于维护。

> 继承是子类使用父类的方法，而多态则是父类使用子类的方法。



**如何理解面向对象**

世间万物皆对象，对象有具体的的实例化，任何方法或者属性都要写在对象(类)里面，就是不断的创建对象使用对象指挥对象做事。



**接口与抽象类的区别**

- 抽象类使用abstract修饰 ，接口使用interface修饰。
- 抽象类可以有普通方法，接口不可有有普通方法只能有抽象方法。
- 抽象类可以有普通属性，接口只能是常量。
- 抽象类和接口不能实例化，就是不能new，也就是不能创建对象，因为不是具体的。
- 抽象类有构造方法，接口没有构造方法。
- 抽象类只支持单继承支持多实现，接口支持多继承。



**类的组成和执行顺序**

- 类的组成：属性 方法 静态块 非静态块。
- 执行顺序：父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法。



**构造方法可否能被重写**

不能被重写，只有继承关系才能重写，构造方法不能被重写，但是能被重载



## 数据类型

**基本数据类型**

Byte（字节型）、short（短整型）、char（字符型） 、int（整型）、float（单精度型/浮点型）、long（长整型）、double（双精度型） 和boolean(布尔类型）。

**引用数据类型**

除了基本的数据类型，其他都是引用数据类型。



**区别**

- 基本类型只能按值传递，封装类按引用传递
- 基本类型在堆栈上分配，对象在堆上分配（对象的引用在堆栈上创建）
  - 基本类型的局部变量在栈上分配，对象的成员变量在堆上分配
- 封装类可以更方便的使用一些基本类型不具备的方法



**==和equals**

- ==
  - 对于基本数类型，== 比较值
  - 对于引用数据类型， == 比较内存地址
- equals
  - 没有重写 equals 时，使用 == 比较地址
  - 可以重写为比较值



## synchronized

[深入理解synchronized底层原理，一篇文章就够了！ - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1465413)

synchronized会锁住类或是该类的某一个实例对象，这取决于他的作用域。

锁类

- 对类的静态方法加锁
- 在同步块中对类加锁

锁对象

- 对该对象的成员方法加锁
- 在同步块中对对象加锁



**同步方法**

方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。**JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法**。

当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。

在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。

如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。



**同步代码块**

**同步块是由monitorenter指令进入，然后monitorexit释放锁**，在执行monitorenter之前需要尝试获取锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，那么就把锁的计数器加1。当执行monitorexit指令时，锁的计数器也会减1。当获取锁失败时会被阻塞，一直等待锁被释放。

值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。

为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。



**底层实现**

[Java-Notes/对象的内存布局.md at master · leosanqing/Java-Notes (github.com)](https://github.com/leosanqing/Java-Notes/blob/master/JVM/对象的内存布局/对象的内存布局.md)

在理解锁实现原理之前先了解一下 Java 的对象头和 Monitor ，在 JVM 中，对象是分成三部分存在的：对象头、实例数据、对齐填充。

![fu98yi2bmj](../img/fu98yi2bmj.jpg)

实例数据和对齐填充与 synchronized 无关。**实例数据**存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐；**对其填充**不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充仅仅是为了使字节对齐。

对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由 `Mark Word` 和 `Class Metadata Address` 组成，**其中** `Mark Word` **存储对象的 hashCode、锁信息或分代年龄或GC标志等信息**，`Class Metadata Address` **是类型指针指向对象的类元数据，JVM 通过该指针确定该对象是哪个类的实例**。

锁也分不同状态，在 JDK6 之后有四个状态：**无锁状态、偏向锁、轻量级锁、重量级锁**，其中无锁就是一种状态了。锁的类型和状态在对象头`Mark Word`中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的`Mark Word`数据。

每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。



**锁膨胀**

锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：**无锁——>偏向锁——>轻量级锁——>重量级锁**，并且膨胀方向不可逆。



[Java-Notes/锁对比.md at master · leosanqing/Java-Notes (github.com)](https://github.com/leosanqing/Java-Notes/blob/master/ConcurrencyProgramming/0-基础/锁对比/锁对比.md)

### 偏向锁

一句话总结它的作用：**减少统一线程获取锁的代价**。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。



**核心思想：**

如果一个线程获得了锁，那么锁就进入偏向模式，此时`Mark Word`的结构也就变为偏向锁结构，**当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查**`Mark Word`**的锁标记位为偏向锁以及当前线程ID等于**`Mark Word`**的ThreadID即可**，这样就省去了大量有关锁申请的操作。



**初始化过程**

- 当锁对象**第一次**被线程获取的时候，虚拟机会将对象头中的锁标志位置为 "01"(偏向模式)
- 同时，使用CAS(如果不了解CAS，可以看这篇文章，[悲观锁和乐观锁](https://github.com/leosanqing/Java-Notes/blob/master/ConcurrencyProgramming/0-基础/悲观锁和乐观锁/悲观锁和乐观锁.md))操作，把获取到这个锁的**线程的ID**记录在对象的MW中，
- **如果 CAS成功，持有偏向锁的线程每次进入这个锁相关的同步块时，虚拟机可以不进行任何同步操作**



**撤销过程**

- 首先暂停拥有偏向锁的线程
- 然后检查持有偏向锁的线程是否活着
  - 不活跃，将对象头设置成无锁状态 (标志位"01"，但不可偏向)
  - 活跃，
    - CAS成功，重新偏向，更改线程ID
    - 失败，恢复成无锁状态，或者变成轻量级锁定状态。





### 轻量级锁

轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。

他的出现并不是代替重量级锁，**而是在没有多线程竞争的前提下，减少系统互斥量操作产生的性能消耗**



**加锁**

- 线程在执行同步块之前，JVM会现在当前线程的**栈帧**中创建用于存储**锁记录**（下图的Lock Record）的空间，并将对象头中的MW复制到**锁记录**中，官方称为 Displaced Mark Word
- 然后，虚拟机将使用CAS操作，将对象的MW更新为指向**锁记录**的指针
  - 如果这个操作成功，那么该线程就有了该对象的锁，并且对象的MW的锁标志位置为 "00"，表示该对象处于轻量级锁定状态
  - 如果更新失败，表示其他线程竞争锁，当前线程尝试使用**自旋**来获取锁



**解锁**

- 使用CAS操作将 Displaced Mark Word 替换回到对象头
  - 如果成功，则说明没有发生竞争
  - 失败，则表示当前锁存在竞争，锁就会膨胀成重量级锁
    - 释放锁，并且唤醒等待的线程



**缺点**

轻量级能提升程序同步性能的依据是"对于绝大部分的锁，**在整个同步周期内都是不存在竞争的**"，这是一个经验数据。

- 如果没有竞争，轻量级锁使用CAS操作，避免使用互斥量
- 如果存在竞争，除了互斥量的开销，还有 CAS的操作，不仅没有提升，反而性能会下降



### 重量级锁

[Java Synchronized 重量级锁原理深入剖析上(互斥篇)_小鱼人爱编程的博客-CSDN博客_java重量级锁原理](https://blog.csdn.net/wekajava/article/details/120306478)

重量级锁引入 ObjectMonitor 类，可在线程间共享，方便其他线程找到被阻塞的该线程。

通过修改 Mark Word 来指向该对象。



**加锁**

- 多次尝试加锁，其中会使用自旋。
- 如果加锁失败，将线程包装，加入阻塞队列。
- 再次尝试，如果失败，将自己挂起。
- 被唤醒后继续尝试获取锁



**解锁**

- 先释放锁
- 如果有线程等待被唤醒，尝试唤醒线程，这过程中可能被其他线程抢占



### 对比

|    锁    |                             优点                             |                      缺点                      |             适用场景              |
| :------: | :----------------------------------------------------------: | :--------------------------------------------: | :-------------------------------: |
|  偏向锁  | 加锁和解锁都不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 |      只有一个线程访问同步块       |
| 轻量级锁 |           竞争的线程不会阻塞，提高了程序的响应速度           | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间 同步块执行速度非常块 |
| 重量级锁 |               线程竞争不使用自旋，不会消耗CPU                |              线程阻塞，响应时间慢              |   追求吞吐量 同步块执行时间较长   |



**锁消除**

消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在 JIT 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。



**锁粗化**

锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。



## JVM



### 内存区域

<img src="../img/Xnip2019-04-07_20-05-33.jpg" alt="Xnip2019-04-07_20-05-33" style="zoom: 50%;" />

- 线程私有
  - 虚拟机栈
  - 本地方法栈（不是所有JVM都有，比如Hotspot）
  - 程序计数器
- 线程共享
  - 方法区
  - 堆



| 数据区     |                                                              |
| ---------- | ------------------------------------------------------------ |
| Java 堆    | 存放对象实例                                                 |
| 方法区     | 类信息、常量、静态变量、即时编译后的代码                     |
| 本地方法栈 | 为虚拟机使用到的Native方法服务                               |
| 程序计数器 | 可以看作是当前线程执行的字节码的行号指令器，为了线程正确切换而服务 |
| 虚拟机栈   | 局部变量表、操作数栈、动态链接、方法出口                     |



#### 线程私有



**虚拟机栈**

java虚拟机栈是**线程私有的**，他的生命周期和线程相同。**他描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直到执行完的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程**。

**栈帧**

他存放了以下重要信息（部分）：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口
- 等……..

**slot**

我们刚刚说到栈帧的数据结构，他存储的重要信息，其中有一个是**局部变量表**，而这个局部变量表也是由一个个小的数据结构组成，他就叫**局部变量空间（slot）**。你也可以把它当成是一个空间大小的度量单位，就像字节一样，因为存储的数据的大小也是用这个衡量的。

局部变量表存放了编译期可知的各种**基本数据类型**(boolean、byte、char、short、int、float、long、double)、**对象引用**(reference类型)和**returnAddress类型**。



**本地方法栈**

[JVM的本地方法栈 - wade&luffy - 博客园 (cnblogs.com)](https://www.cnblogs.com/wade-luffy/p/5813747.html)

**注意：有的虚拟机中是将本地方法栈和虚拟机栈合在一起的，比如Hotspot虚拟机**

本地方法栈和虚拟机栈差不多，不过 Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机使用到的Native方法服务。我们知道Java虚拟机有一部分是用其他语言编写的，比如C/C++,因此他有一部分是这些语言的类库方法。

**Navtive 方法是 Java 通过 JNI 直接调用本地 C/C++ 库**，可以认为是 Native 方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。当线程调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 虚拟机栈。然而当它调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法。



**程序计数器**

程序计数器是线程私有的，他是一块较小的内存空间，他可以看作是当前线程执行的字节码的行号指令器。在虚拟机的概念模型里(仅仅是概念模型，不同虚拟机的实现方式可能有更高效的方法)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等基础功能都需要依赖这个计数器。

**为什么线程私有**

Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令、因此**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储**，我们称这类内存区域为"线程私有"的内存。



#### 线程共享

这里是GC垃圾回收重点"照顾"的对象，可以参考：[JVM垃圾回收](https://github.com/leosanqing/Java-Notes/blob/master/JVM/JVM垃圾回收.md)



**Java堆**

对于大所数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，也被线程共享。**唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存**

他还可以再细分为：新生代，老年代



**方法区**

和Java堆一样是线程共享的，它用于存储已经被虚拟机加载的：

- 类信息
- 常量
- 静态变量
- 即时编译后的代码
- 等…...



### 垃圾回收

主要回收的内容是Java堆区和方法区。



**引用计数法**

缺点：互相引用的对象不会被回收

**可达性分析法**

从 GC ROOT开始，随着引用链一步一步搜索。如果不可达，证明对象不可用。

可以作为 GC ROOT 的对象

- 虚拟机栈中引用的对象
- 本地方法栈中 JNI(即一般说的Native方法)引用的对象
- 本地方法区中
  - 类静态属性引用的对象
  - 常量引用的对象



#### GC算法

**标记/清除**

标记需要清除的对象然后清除。

**缺点**

- 效率：标记和清除的效率都不高
- 空间：清理后会产生大量的不连续的内存，之后分配大内存对象时，不得不提前触发垃圾回收



**标记/复制**

将内存分为两块，每次只使用其中一块。每次垃圾回收时，将存活的对象复制到另一块，然后清理那块全部空间。

比较适合可以大量进行垃圾回收的新生代。

**缺点**

- 内存少了一半

> 为了解决这个问题，JVM将新生代的 Eden区和其中一个survivor区域划分比例调整为8：1.而survivor共有两个，每次只用其中一个，另一个用来复制，存放活着的对象



**标记/整理**

标记过程一样，就是清除的时候，将所有活着的对象移到一端。然后清理剩下的区域

**缺点**

-  回收效率不高。

> 所以一般用在老年代的回收



**分代收集**

主流的虚拟机都采用这种算法

主要是根据不同代的特点，选择相对合适的上述算法。

比如Java新生代对象存活率比较低，有大批的对象死去，所以采用`标记-复制`算法。

而老年代的对象相对比较稳定，存活率较高而且对象较少，也没有额外的空间对他进行分配担保，所以就采用`标记-整理`算法

> 老年代：
>
> - 大对象（字符串与数组），是指需要大量连续内存空间的java对象。
> - 长期存活的对象可以从年轻代进入老年代



## HashSet

- 是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。
- 当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。
- HashSet的其他操作都是基于HashMap的。







## HashMap

[图解 HashMap 源码——逐行分析源码，面试再也不怕被问HashMap了_every__day的博客-CSDN博客](https://blog.csdn.net/every__day/article/details/114118922)

在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。

而JDK1.8中，HashMap采用位桶+链表+红黑树实现，当数组长度大于等于64，且链表长度大于8，将链表转换为红黑树，这样大大减少了查找时间。

首先有一个数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。



**为什么不直接用红黑树**

红黑树平均查找长度是 log(n) ，链表平均查找长度是 n/2 。

当 n<8 时，平均查找长度相近，但是红黑树的插入插入删除时的旋转开销都较大，节点占用的空间较大。所以选择使用链表。

当 n=8 时，平均查找长度有了较显著的差别，这时转化为树才有了意义。

所以说这种策略也是一种时间和空间上的妥协。



**扩容**

初始化后首次插入数据时，先发生 resize 扩容再插入数据。之后每当插入的数据到达阈值时就会发生 resize ，这时是先插入数据再 resize 。



**为什么不使用 AVL 树**

AVL 树是平衡树，在查找时效率比红黑树高一点。

红黑树是近似平衡的树，在维护平衡的成本上，要比AVL树要低。

所以红黑树的插入、删除、查找等各种操作的性能都比较稳定。



### 线程不安全

HashMap 的线程不安全最主要是体现在扩容和插入中，这里又分为 JDK7 和 JDK8 两种情况。

**JDK7**

JDK7 中节点插入采用头插法

- 在扩容中：假设线程1在遍历过程中，拿到了下一次准备遍历的next，这时线程2也在扩容，会修改next对象。当线程1继续执行时，可能会造成两个Entry互相引用，造成**死循环**，并且**丢失元素**。
- 在插入中：假设两个线程同时拿到链表头，第一个链表插入后，第二个链表的插入就会覆盖第一个链表的操作，造成**元素覆盖**。

**JDK8**

JDK8 中节点插入采用尾插法，避免了链表成环，造成死循环。

- 插入中：会造成**元素覆盖**。



## HashTable

HashTable 无论 key 还是 value 都不能为 null。

Hashtable是线程安全的，多个线程可以共享一个Hashtable。

实现线程安全的方式是在修改数据时锁住整个Hashtable，效率低。



## ConcurrentHashMap

[java-并发-ConcurrentHashMap高并发机制-jdk1.8_阿里Darker-CSDN博客](https://blog.csdn.net/jianghuxiaojin/article/details/52006118)

[图解 ConCurrentHashMap ——从源码层面，弄清楚它是怎么控制并发的_every__day的博客-CSDN博客](https://blog.csdn.net/every__day/article/details/114293107)

[ConCurrentHashMap并发环境时，如何计数的？—— sumCount()、fullAddCount()_every__day的博客-CSDN博客_concurrenthashmap计数](https://blog.csdn.net/every__day/article/details/115030000)

ConcurrentHashMap 1.8 采用Node + CAS + Synchronized来保证并发安全进行实现，采用table数组＋链表＋红黑树的存储结构。以table数组元素作为锁，利用CAS+Synchronized来保证并发更新的安全，从而实现了对每个数组元素（Node）进行加锁，进一步减少并发冲突的概率。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，允许多个修改操作并发进行。

<img src="https://img-blog.csdnimg.cn/20200409211332776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjUzMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"  />



### 区别

- key 和 value 均不能为空



### 内部类



#### Node

Node 是最核心的内部类，它包装了 key-value 键值对，所有插入 ConcurrentHashMap 的数据都包装在这里面。

- 这个 Node 内部类与 HashMap 中定义的 Node 类很相似，但是有一些差别，
-   它对 value 和 next 属性设置了 **volatile** 同步锁 
-   它不允许调用 setValue 方法直接改变 Node 的 value 域 
-   它增加了 find 方法辅助 map.get() 方法 



#### TreeNode

树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为 TreeNode。但是与 HashMap 不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成 TreeNode 放在 TreeBin 对象中，由 TreeBin 完成对红黑树的包装。

而且 TreeNode 在 ConcurrentHashMap 集成自 Node 类，而并非 HashMap 中的集成自 LinkedHashMap.Entry<K,V> 类，也就是说 TreeNode 带有 next 指针，这样做的目的是方便基于 TreeBin 的访问。



#### TreeBin

这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。它代替了TreeNode 的根节点，也就是说在实际的 ConcurrentHashMap “数组” 中，存放的是 TreeBin 对象，而不是 TreeNode 对象，这是与 HashMap 的区别。另外这个类还带有了读写锁。

这里仅贴出它的构造方法。可以看到在构造 TreeBin 节点时，仅仅指定了它的 hash 值为 TREEBIN 常量，这也就是个标识为。同时也看到我们熟悉的红黑树构造方法。



#### ForwardingNode

一个用于连接两个 table 的节点类。它包含一个 nextTable 指针，用于指向下一张表。而且这个节点的 key value next 指针全部为 null，它的 hash 值为 -1。这里面定义的 find 的方法是从 nextTable 里进行查询节点，而不是以自身为头节点进行查找



### CAS

JDK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用CAS操作。

CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。

乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过自旋来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。



### 计数

对于 ConcurrentHashMap 来说，这个 table 里到底装了多少东西其实是个不确定的数量，因为不可能在调用 size() 方法的时候像 GC 的 “stop the world” 一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap 也是大费周章才计算出来的。

计数的方法有 size 和 mappingSize，而这两个方法都是调用 sumCount 方法。

- size 返回 int，是将 long 强转为 int
- mappingSize 返回 long，可计数的范围更大

sumCount 统计 baseCount 和各个 CounterCell 的和。

```java
final long sumCount() {                      
    CounterCell[] as = counterCells;         
    CounterCell a;                           
    long sum = baseCount;                    
    if (as != null) {                        
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)         
                sum += a.value;              
        }                                    
    }                                        
    return sum;                              
}                                            
```



计数时，要么修改了 `baseCount`，要么 修改了 `CounterCell` 对象中 `value` 的值。

在 put 和 remove 中，都调用了 addCount 这个方法。这个的一个重要功能就是计数。

#### 总结

- 无竞争条件下，执行 put() 方法时，操作 baseCount 实现计数
- 首次竞争条件下，执行 put() 方法，会初始化 CounterCell ，并实现计数
- CounterCell 一旦初始化，计数就优先使用 CounterCell
- 每个线程，要么修改 CounterCell、要么修改 baseCount，实现计数
- CounterCell 在竞争特别严重时，会扩容。（扩容上限与 CPU 核数有关，不会一直扩容）







## 设计模式



### 单例模式

单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

**特点**

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。

**饿汉式**

饿汉式单例模式只要调用了该类，就会实例化一个对象，但有时我们并只需要调用该类中的一个方法，而不需要实例化一个对象，所以饿汉式是比较消耗资源的。

```java
public class Singleton {
    private static Singleton ourInstance;
    
    static {
         ourInstance = new Singleton();
    }

    public static Singleton getInstance() {
        return ourInstance;
    }

    private Singleton() {}
}
```

**懒汉式**

```java
public class Singleton {
    //volatile的作用是：保证可见性、禁止指令重排序，但不能保证原子性
    private volatile static Singleton ourInstance;

    public static Singleton getInstance() {
        if (null == ourInstance) {
            synchronized (Singleton.class) {
                if (null == ourInstance) {
                    ourInstance = new Singleton();
                }
            }
        }
        return ourInstance;
    }

    private Singleton() {
    }
}
```



### 模板模式

父类定义整个处理流程，子类实现具体步骤。



**登场角色**

- AbstractClass（抽象类）

AbstractClass 角色不仅负责实现模板方法，还负责声明在模板方法中所使用到的抽象方法。这些抽象方法由子类 ConcreteClass 角色负责实现。

- ConcreteClass（具体类）

该角色负责具体实现 AbstractClass 角色中定义的抽象方法。这里实现的方法将会在 AbstractClass 角色的模板方法中被调用。



**优点**

在父类的模板方法中编写了算法，因此无需在每个子类中再编写算法。



**一致性**

运用多态，将子类的实例保存在父类的变量中，再来调用display。即使没有用 instanceof 等指定子类的种类，程序也能正常工作。

无论在父类类型的变量中保存哪个子类的实例，程序都可以正常工作，这种原则称为 LSP。





### 工厂模式

在父类中规定处理的流程，在子类中实现具体的处理模式。



**登场角色**

- Product（产品）

Product 角色属于框架这一方，是一个抽象类。它定义了在 Factory Method 模式中生成的那些实例所持有的接口（API），但具体的处理则由子类 ConcreteProduct 角色决定。

- Creator（创建者）

Creator 角色属于框架这一方，它是负责生成Product角色的抽象类，但具体的处理则由子类 ConcreteCreator 角色决定。

Creator 角色对于实际负责生成实例的 ConcreteCreator 一无所知，它唯一知道的就是，只要调用 Product 角色和生成实例的方法，就可以生成 Product 的实例。

**不用 new 关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类耦合。**

- ConcreteProduct（具体的产品）

ConcreteProduct 角色属于具体加工这一方，他决定了具体的产品。

- ConcreteCreator（具体的创建者）

ConcreteCreator 角色属于具体加工这一方，他负责生成具体的产品。



**优点**

使用已有的框架生成全新的类时，也完全不需要对 framework 进行修改。
